[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "Scraping online press articles in R\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSocial research workshop\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFormula 1\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/Formula 1/index.html",
    "href": "blog/Formula 1/index.html",
    "title": "Formula 1",
    "section": "",
    "text": "My whole family has been forever fascinated with car racing. This short exercise is therefore somewhat of a homage to the discipline.\nThe following charts were the excuse to try out the packages highcharter (for drilldown graphs) and gt (for tables). Both were heavily inspired by Tanya Shapiro’s work. The data used for this project can be found on Kaggle.\n\n\nSetup code\n# Libraries\npackages &lt;- c('tidyverse','MetBrewer','highcharter', 'gt', 'gtExtras')\ninstall.packages(setdiff(packages, rownames(installed.packages()))) \nlibrary(gt)\nlibrary(gtExtras)\nlibrary(tidyverse)\nlibrary(MetBrewer)\nlibrary(highcharter)\nrm(packages)\n\n\n# Importing data\ndrivers &lt;- read_csv(\"archive/drivers.csv\", show_col_types = F)\nresults &lt;- read_csv('archive/results.csv', show_col_types = F)\nflags &lt;- read_csv(\"flags_iso.csv\")\n\n# Data cleaning\n## setting mixed nationalities to first one\ndrivers$nationality &lt;- gsub('-Italian', '', drivers$nationality)\ndrivers$nationality &lt;- gsub('East German', 'German', drivers$nationality)\n## recoding NAs in number column\ndrivers$number &lt;- ifelse(drivers$number == '\\\\N', NA, drivers$number)\n\n# Defining wins and podiums vectors\nwins &lt;- \nresults |&gt; \n  filter(position == 1) |&gt; \n  count(driverId) |&gt; \n  rename(wins = n)\npodiums &lt;- \n  results |&gt; \n  filter(position == 1 | position == 2 | position == 3) |&gt; \n  count(driverId) |&gt; \n  rename(podiums = n)\n\n# Merging with driver data\ndrivers &lt;- full_join(drivers, wins)\ndrivers &lt;- full_join(drivers, podiums)\nrm(wins, podiums)\n\n# Creating full name column\ndrivers &lt;- drivers |&gt; \n  mutate(name = paste(forename, surname, sep = ' '))\n\n# Defining continent variable\nafrica &lt;- c('Algerian','Angolan','Beninese','Batswana','Burkinabe','Burundian','Cameroonian','Cape Verdean','Central African','Chadian','Comoran','Congolese (Democratic Republic of the Congo)','Congolese (Republic of the Congo)','Ivorian (Côte d’Ivoire)','Djiboutian','Egyptian','Equatorial Guinean','Eritrean','Ethiopian','Gabonese','Gambian','Ghanaian','Guinean','Guinea-Bissauan','Kenyan','Lesothoan','Liberian','Libyan','Malagasy','Malawian','Malian','Mauritanian','Mauritian','Moroccan','Mozambican','Namibian','Nigerien','Nigerian','Rwandan','Sahrawi','Saint Helenian','Sao Tomean','Senegalese','Seychellois','Sierra Leonean','Somali','South African','South Sudanese','Sudanese','Swazi','Tanzanian','Togolese','Tunisian','Ugandan','Zambian','Zimbabwean')\n\nasia &lt;- c('Afghan','Armenian','Azerbaijani','Bahraini','Bangladeshi','Bhutanese','Bruneian','Cambodian','Chinese','Cypriot','Filipino','Georgian','Indian','Indonesian','Iranian','Iraqi','Israeli','Japanese','Jordanian','Kazakhstani','Kuwaiti','Kyrgyzstani','Laotian','Lebanese','Malaysian','Maldivian','Mongolian','Myanmar (Burmese)','Nepalese','North Korean','Omani','Pakistani','Palestinian','Philippine','Qatari','Russian','Saudi Arabian','Singaporean','South Korean','Sri Lankan','Syrian','Taiwanese','Tajikistani','Thai','Timorese','Turkish','Turkmen','Emirati','Uzbekistani','Vietnamese','Yemeni')\n\neurope &lt;- c('Albanian','Andorran','Austrian','Belarusian','Belgian','Bosnian','Bulgarian',\n'Croatian','Cypriot','Czech','Danish','Estonian','Finnish','French','German', 'East German', 'Rhodesian', 'Greek','Hungarian','Icelandic','Irish','Italian','Kosovar','Latvian','Liechtensteiner','Lithuanian','Luxembourgish','Macedonian','Maltese','Moldovan','Monegasque','Montenegrin','Dutch','Norwegian','Polish','Portuguese','Romanian','Russian','Sammarinese','Serbian','Slovak','Slovenian','Spanish','Swedish','Swiss','Ukrainian','British','Vatican City State (Holy See)')\n\nnamerica &lt;- c('American','Antiguan and Barbudan','Bahamian','Barbadian','Belizean','Canadian','Costa Rican','Cuban','Dominican (Dominican Republic)','Dominican (Dominica)','Salvadoran','Grenadian','Guatemalan','Haitian','Honduran','Jamaican','Kittitian and Nevisian','Lucian','Mexican','Nicaraguan','Panamanian','Saint Vincent and the Grenadines','Trinidadian and Tobagonian')\n\nsamerica &lt;- c('Argentine','Bolivian','Brazilian','Chilean','Colombian','Ecuadorian','Guyanese','Paraguayan','Peruvian','Surinamese','Uruguayan','Venezuelan')\n\noceania &lt;- c('Australian','Fijian','Kiribati','Marshallese','Micronesian','Nauruan','New Zealander','Palauan','Papua New Guinean','Samoan','Solomon Islander','Tongan','Tuvaluan','Vanuatuan')\n\ndrivers$continent &lt;- ifelse(drivers$nationality %in% africa, 'African',\n                       ifelse(drivers$nationality %in% asia, 'Asian',\n                              ifelse(drivers$nationality %in% europe, 'European',\n                                     ifelse(drivers$nationality %in% namerica, 'North American',\n                                            ifelse(drivers$nationality %in% samerica, 'South American',\n                                                   ifelse(drivers$nationality %in% oceania, 'Oceanian', NA))))))\n\nrm(asia, africa, europe, namerica, samerica, oceania)\n\n\n# Creating graphics df\n## total drivers by nationality\nby_cont &lt;- drivers |&gt; \n  group_by(continent) |&gt; \n  summarise(drivers = n())\n## Nest continent &lt;- nationality &lt;- wins\nby_nat &lt;- drivers |&gt; \n  group_by(continent, nationality) |&gt; \n  summarise(drivers = n()) |&gt; \n  group_nest(continent) |&gt; \n  mutate(\n    id = continent,\n    type= 'pie',\n    data = purrr::map(data, mutate, name = nationality, y  = drivers, ),\n    data = purrr::map(data, list_parse)\n  )"
  },
  {
    "objectID": "blog/Formula 1/index.html#formula-1",
    "href": "blog/Formula 1/index.html#formula-1",
    "title": "Formula 1",
    "section": "",
    "text": "My whole family has been forever fascinated with car racing. This short exercise is therefore somewhat of a homage to the discipline.\nThe following charts were the excuse to try out the packages highcharter (for drilldown graphs) and gt (for tables). Both were heavily inspired by Tanya Shapiro’s work. The data used for this project can be found on Kaggle.\n\n\nSetup code\n# Libraries\npackages &lt;- c('tidyverse','MetBrewer','highcharter', 'gt', 'gtExtras')\ninstall.packages(setdiff(packages, rownames(installed.packages()))) \nlibrary(gt)\nlibrary(gtExtras)\nlibrary(tidyverse)\nlibrary(MetBrewer)\nlibrary(highcharter)\nrm(packages)\n\n\n# Importing data\ndrivers &lt;- read_csv(\"archive/drivers.csv\", show_col_types = F)\nresults &lt;- read_csv('archive/results.csv', show_col_types = F)\nflags &lt;- read_csv(\"flags_iso.csv\")\n\n# Data cleaning\n## setting mixed nationalities to first one\ndrivers$nationality &lt;- gsub('-Italian', '', drivers$nationality)\ndrivers$nationality &lt;- gsub('East German', 'German', drivers$nationality)\n## recoding NAs in number column\ndrivers$number &lt;- ifelse(drivers$number == '\\\\N', NA, drivers$number)\n\n# Defining wins and podiums vectors\nwins &lt;- \nresults |&gt; \n  filter(position == 1) |&gt; \n  count(driverId) |&gt; \n  rename(wins = n)\npodiums &lt;- \n  results |&gt; \n  filter(position == 1 | position == 2 | position == 3) |&gt; \n  count(driverId) |&gt; \n  rename(podiums = n)\n\n# Merging with driver data\ndrivers &lt;- full_join(drivers, wins)\ndrivers &lt;- full_join(drivers, podiums)\nrm(wins, podiums)\n\n# Creating full name column\ndrivers &lt;- drivers |&gt; \n  mutate(name = paste(forename, surname, sep = ' '))\n\n# Defining continent variable\nafrica &lt;- c('Algerian','Angolan','Beninese','Batswana','Burkinabe','Burundian','Cameroonian','Cape Verdean','Central African','Chadian','Comoran','Congolese (Democratic Republic of the Congo)','Congolese (Republic of the Congo)','Ivorian (Côte d’Ivoire)','Djiboutian','Egyptian','Equatorial Guinean','Eritrean','Ethiopian','Gabonese','Gambian','Ghanaian','Guinean','Guinea-Bissauan','Kenyan','Lesothoan','Liberian','Libyan','Malagasy','Malawian','Malian','Mauritanian','Mauritian','Moroccan','Mozambican','Namibian','Nigerien','Nigerian','Rwandan','Sahrawi','Saint Helenian','Sao Tomean','Senegalese','Seychellois','Sierra Leonean','Somali','South African','South Sudanese','Sudanese','Swazi','Tanzanian','Togolese','Tunisian','Ugandan','Zambian','Zimbabwean')\n\nasia &lt;- c('Afghan','Armenian','Azerbaijani','Bahraini','Bangladeshi','Bhutanese','Bruneian','Cambodian','Chinese','Cypriot','Filipino','Georgian','Indian','Indonesian','Iranian','Iraqi','Israeli','Japanese','Jordanian','Kazakhstani','Kuwaiti','Kyrgyzstani','Laotian','Lebanese','Malaysian','Maldivian','Mongolian','Myanmar (Burmese)','Nepalese','North Korean','Omani','Pakistani','Palestinian','Philippine','Qatari','Russian','Saudi Arabian','Singaporean','South Korean','Sri Lankan','Syrian','Taiwanese','Tajikistani','Thai','Timorese','Turkish','Turkmen','Emirati','Uzbekistani','Vietnamese','Yemeni')\n\neurope &lt;- c('Albanian','Andorran','Austrian','Belarusian','Belgian','Bosnian','Bulgarian',\n'Croatian','Cypriot','Czech','Danish','Estonian','Finnish','French','German', 'East German', 'Rhodesian', 'Greek','Hungarian','Icelandic','Irish','Italian','Kosovar','Latvian','Liechtensteiner','Lithuanian','Luxembourgish','Macedonian','Maltese','Moldovan','Monegasque','Montenegrin','Dutch','Norwegian','Polish','Portuguese','Romanian','Russian','Sammarinese','Serbian','Slovak','Slovenian','Spanish','Swedish','Swiss','Ukrainian','British','Vatican City State (Holy See)')\n\nnamerica &lt;- c('American','Antiguan and Barbudan','Bahamian','Barbadian','Belizean','Canadian','Costa Rican','Cuban','Dominican (Dominican Republic)','Dominican (Dominica)','Salvadoran','Grenadian','Guatemalan','Haitian','Honduran','Jamaican','Kittitian and Nevisian','Lucian','Mexican','Nicaraguan','Panamanian','Saint Vincent and the Grenadines','Trinidadian and Tobagonian')\n\nsamerica &lt;- c('Argentine','Bolivian','Brazilian','Chilean','Colombian','Ecuadorian','Guyanese','Paraguayan','Peruvian','Surinamese','Uruguayan','Venezuelan')\n\noceania &lt;- c('Australian','Fijian','Kiribati','Marshallese','Micronesian','Nauruan','New Zealander','Palauan','Papua New Guinean','Samoan','Solomon Islander','Tongan','Tuvaluan','Vanuatuan')\n\ndrivers$continent &lt;- ifelse(drivers$nationality %in% africa, 'African',\n                       ifelse(drivers$nationality %in% asia, 'Asian',\n                              ifelse(drivers$nationality %in% europe, 'European',\n                                     ifelse(drivers$nationality %in% namerica, 'North American',\n                                            ifelse(drivers$nationality %in% samerica, 'South American',\n                                                   ifelse(drivers$nationality %in% oceania, 'Oceanian', NA))))))\n\nrm(asia, africa, europe, namerica, samerica, oceania)\n\n\n# Creating graphics df\n## total drivers by nationality\nby_cont &lt;- drivers |&gt; \n  group_by(continent) |&gt; \n  summarise(drivers = n())\n## Nest continent &lt;- nationality &lt;- wins\nby_nat &lt;- drivers |&gt; \n  group_by(continent, nationality) |&gt; \n  summarise(drivers = n()) |&gt; \n  group_nest(continent) |&gt; \n  mutate(\n    id = continent,\n    type= 'pie',\n    data = purrr::map(data, mutate, name = nationality, y  = drivers, ),\n    data = purrr::map(data, list_parse)\n  )"
  },
  {
    "objectID": "blog/Formula 1/index.html#driver-nationality",
    "href": "blog/Formula 1/index.html#driver-nationality",
    "title": "Formula 1",
    "section": "Driver nationality",
    "text": "Driver nationality\nF1 drivers come from all over the world: all continents are or have been represented in the driver’s championship. However, not every one of them is equally represented. The interactive graph below displays the distribution of the drivers’ home countries.\n\n\nDrilldown chart code\n# Making basic pie chart\ndonut_chart &lt;- by_cont |&gt;\n  hchart('pie',\n         hcaes(x = continent, y = drivers, drilldown = continent),\n         name = 'Drivers'\n         ) |&gt; \n  hc_plotOptions(pie = list(innerSize = '70%')) |&gt; \n  hc_title(text = 'Number of F1 drivers by geographical ')\n\n# Making drilldown active\ndrilldown_chart &lt;- donut_chart |&gt; \n  hc_drilldown(\n    #map to data\n    series = list_parse(by_nat),\n    allowPointDrilldown = TRUE,\n    #set stylings of data labels that offer drill down views\n    activeDataLabelStyle = list(\n      textDecoration=\"none\",\n      color=\"black\"\n    )\n  )\n\ncustom_theme &lt;- hc_theme(\n  colors = met.brewer('Degas'),\n  chart = list(\n    backgroundColor = NULL\n  ),\n  title = list(\n    style = list(\n      color = \"#333333\",\n      fontFamily = \"Archivo\",\n      fontWeight=\"bold\"\n    )\n  ),\n  xAxis = list(\n    labels=list(style = list(\n      color = \"#666666\",\n      fontFamily = \"Archivo\"\n    ))\n  ),\n  yAxis = list(\n    labels=list(style = list(\n      color = \"#666666\",\n      fontFamily = \"Archivo\"\n    ))\n  ),\n  tooltip = list(\n    style = list(\n      fontFamily = \"Archivo\"\n    )\n  ),\n  plotOptions = list(\n    series = list(\n      dataLabels = list(style=list(fontFamily = \"Archivo\")\n      ))\n  )\n)\ndrilldown_chart |&gt; \n  hc_add_theme(custom_theme)"
  },
  {
    "objectID": "blog/Formula 1/index.html#driver-stats",
    "href": "blog/Formula 1/index.html#driver-stats",
    "title": "Formula 1",
    "section": "Driver stats",
    "text": "Driver stats\n\n\nCode prep\n# Building df\nwintable &lt;-  drivers |&gt;\n  select(name, nationality, wins, podiums) |&gt; \n  filter(!is.na(wins)) |&gt;\n  arrange(desc(wins)) |&gt;\n  slice(1:20)\npodtable &lt;-  drivers |&gt;\n  select(name, nationality, podiums, wins) |&gt; \n  filter(!is.na(podiums)) |&gt;\n  arrange(desc(podiums)) |&gt;\n  slice(1:20)\n\nwintable$nationality &lt;- c('GB', 'DE', 'NL', 'DE', 'FR', 'BR', 'ES', 'GB', 'GB', 'AT', 'GB', 'AR', 'DE', 'BR', 'GB', 'FI', 'FI', 'GB', 'GB', 'BR')\npodtable$nationality &lt;- c('GB', 'DE', 'DE', 'NL', 'ES', 'FR', 'FI', 'BR', 'BR', 'FI', 'GB', 'BR', 'GB', 'DE', 'AT', 'FI', 'GB', 'AT', 'AR', 'GB')\n\ntottable &lt;- full_join(wintable, podtable)\n# Country flag images\nflags &lt;- flags |&gt; \n  select(URL, `Alpha-2 code`)\n## merge\nwintable &lt;- left_join(wintable, flags, by = join_by('nationality' == `Alpha-2 code`)) |&gt; \n  select(name, URL, wins) |&gt; \n  rename(nationality = URL)\npodtable &lt;- left_join(podtable, flags, by = join_by('nationality' == `Alpha-2 code`)) |&gt; \n  select(name, URL, podiums) |&gt; \n  rename(Name = name,\n         Nationality = URL,\n         Podiums = podiums)\ntottable &lt;- left_join(tottable, flags, by = join_by('nationality' == `Alpha-2 code`)) |&gt;\n  select(name, URL, wins, podiums) |&gt; \n  rename(Name = name,\n         Nationality = URL,\n         Podiums = podiums,\n         Wins = wins)\n\ndtable &lt;- bind_cols(wintable, podtable)\nrm(wintable, podtable)\n\n\nThe rankings of the most podiums and the most wins do not necessarily coincide. Below are two tables with these two rankings. Below is a web-friendly, responsive table with the corresponding data. In the source code, a print-ready static table is also available.\n\n\nTable design\n# # Static table\n# dtable |&gt; \n#   gt() |&gt; \n#   tab_header(\n#     title = md(\"## Top ten F1 drivers\")\n#   ) |&gt; \n#   gt_img_rows(columns = Nationality, height = 15) |&gt; \n#   gt_img_rows(columns = nationality, height = 15) |&gt; \n#   cols_align(\n#     align = \"center\",\n#     columns = 2:3) |&gt; \n#   cols_align(\n#     align = 'center',\n#     columns = 4:5\n#   ) |&gt; \n#   tab_spanner(label = 'Most wins',\n#               columns = 2:3) |&gt; \n#   tab_spanner(label = 'Most podiums',\n#               columns = 5:6) |&gt;\n#   gt_theme_538()\n\n# Responsive table\ntottable |&gt; \n  gt(rowname_col = 'Name') |&gt; \n  tab_header(title = html('&lt;h2&gt;Top F1 drivers&lt;/h2&gt;'),\n             ) |&gt; \n  fmt_image(Nationality, height = 15) |&gt; \n  cols_align(align = 'center', columns = 2:4) |&gt; \n  opt_interactive(use_pagination = T,\n                  use_sorting = T) |&gt; \n  tab_options(table.background.color = 'white',\n              table.font.style = 'Roboto',\n              table.border.top.color = 'white',\n              heading.align = 'center',\n              row.striping.include_table_body =FALSE,\n              heading.border.bottom.color = \"white\",\n              row_group.border.bottom.color = \"white\",\n              row_group.border.top.color = \"white\"\n              )\n\n\n\n\n\nTop F1 drivers"
  },
  {
    "objectID": "blog/Web scraping/index.html",
    "href": "blog/Web scraping/index.html",
    "title": "Scraping online press articles in R",
    "section": "",
    "text": "When I had to choose the topic and methods for my Master’s thesis, I decided it would be a great idea to use it as an excuse to start experimenting with natural language processing. Focusing on the Umbria region, where I grew up, I decided to embark on the completely new task of scraping and analysing local press articles and YouTube videos using the tools of computational social science. This is the first of a series of blog posts on the process of doing just that in R, from a beginner’s perspective.\nIn this article, we will be using the local newspaper Terninrete as an example. You can find the entire corpus I built with these methods at this link, and the complete code for all the scrapers through the &lt;/&gt; Code button at the top of this page."
  },
  {
    "objectID": "blog/Web scraping/index.html#parsing-or-scraping",
    "href": "blog/Web scraping/index.html#parsing-or-scraping",
    "title": "Scraping online press articles in R",
    "section": "Parsing or scraping?",
    "text": "Parsing or scraping?\nWe refer to web parsing when we extract organised and formatted data, translating it into a format that we (and our machine) understand. In the context of textual analysis, this generally consists of downloading and reading xml files. What we’re going to focus on here is web scraping, which consists of directly attacking a website’s html and turning it into a viable format for data analysis.\nThe packages you’ll need for his project are: rvest, future, tidyverse, progressr, furrr.\n\n\n\n\n\n\nImportant\n\n\n\nI will not discuss the ethics of web scraping in this article. If you are just starting out, I really recommend this short article on the topic for some quick and easy tips on how to be an ethical scraper and site owner.\n\n\n\n\n\n\n\n\nWhat I assume you already know\n\n\n\n\n\nYou’ll need to already be well versed in R to understand the content of this blog post. If you’re not familiar with R programming, I really recommend the R for Data Science manual. If you want some more step-by-step instructions on how to go about computational social science stuff, I found Felix Lennert’s tutorials to be very helpful."
  },
  {
    "objectID": "blog/Web scraping/index.html#define-the-urls",
    "href": "blog/Web scraping/index.html#define-the-urls",
    "title": "Scraping online press articles in R",
    "section": "Define the URLs",
    "text": "Define the URLs\nFirst thing to do is define a vector of links to be scraped. In this specific case, the linksvector is simply a link of each one of the 2984 pages of articles posted by Terninrete:\n\nlinks &lt;- paste0('https://terninrete.it/tutti-gli-articoli/page/', c(1:2984), '/')"
  },
  {
    "objectID": "blog/Web scraping/index.html#retrieve-data",
    "href": "blog/Web scraping/index.html#retrieve-data",
    "title": "Scraping online press articles in R",
    "section": "Retrieve data",
    "text": "Retrieve data\nThis passage is at the core of the scraping process. Given an URL, we use rvest::read_html to load a page HTML, then we define a variable containing the information we need (in this case all the articles’ urls) and we use the functions rvest::html_elements and rvest::html_attr to tell R where to find the information. In this case, we copy-paste the node we found with selectorgadget as a string inside html_elements, and then tell rvest to scrape the links at that location by targeting the appropriate html attribute (href).\n\nhtml &lt;- read_html(link) # load page HTML\n    \nurl &lt;- html |&gt; \n  html_elements('.jeg_post_title a') |&gt; # scrape article URLs\n  html_attr('href')"
  },
  {
    "objectID": "blog/Web scraping/index.html#automating-the-process",
    "href": "blog/Web scraping/index.html#automating-the-process",
    "title": "Scraping online press articles in R",
    "section": "Automating the process",
    "text": "Automating the process\nNobody has time to run the scraper manually 2984 times, so we have a few options to automate the process. The easiest and most basic one is a for loop. we simply iterate the retrieval process for every item in our links vector:\n\nTerninrete &lt;- tibble( # setup tibble\n    url = character()\n    )\n\nfor (i in 1:NROW(links)) {\n  print(paste('scraping article number', i, 'of', NROW(article_urls)))\n  \n  html &lt;- read_html(links[i]) # load page HTML\n    \n  url &lt;- html |&gt; \n    html_elements('.jeg_post_title a') |&gt; # scrape article URLs\n    html_attr('href')\n  \n  n_row &lt;- tibble(\n    url = url\n    )\n  \n  Terninrete &lt;- n_row |&gt; \n    bind_rows(Terninrete) # append to original df\n  \n}\n\nAnother option is defining a scraping function and then mapping it to the same vector, taking advantage of purr::map(). This is, in my opinion, a much better option: it lets us take care of errors when they arise, and potentially optimise the process to reduce runtimes, sparing us a lot of headaches and execution halts.\n\nDefining a scraping function\nIt is always a good idea to wrap one’s functions inside a tryCatch() command, to instruct R on what to do when the function fails. In this case, we tell it to return a tibble row with the URLs if the function works properly, and a NA_character_ if an error arises.\n\nurl_scrape &lt;- function(link) {\n  tryCatch({\n    \n    html &lt;- read_html(link) # Load page HTML\n    \n    url &lt;- html |&gt; \n      html_elements('.jeg_post_title a') |&gt; # scrape article URLs\n      html_attr('href')\n    \n    return(tibble(url = url))\n    \n  }, error = function(e) {\n    \n    return(tibble(url = NA_character_, errore = as.character(e)))\n    \n  })\n}\n\n\n\nMapping it to an URL vector\nThe scraper is basically done, we can then easily map it to the links vector:\n\narticle_links &lt;- map(links, url_scrape(link))"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "UmbriaPress Corpus\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUmbria - Principali indicatori demografici\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRxR Questionnaire - 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInequality and poverty report\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/Umbria demografia/Index.html",
    "href": "projects/Umbria demografia/Index.html",
    "title": "Umbria - Principali indicatori demografici",
    "section": "",
    "text": "Exam paper written for an international demography course at the Alma Mater Studiorum - University of Bologna (prof. Rosella Rettaroli). The following text is in Italian, the language in which the course was offered.\nUmbria is a moderate-sized region in central Italy. On 1 January 2019, the Umbria population was 882,015. Of these, 13.8% were at least 75 years old (ISTAT 2019). Made famous by its natural, artistic and cultural heritage, as well as by its curious status as the only region in central Italy not to have any sea frontage, Umbria is a perfect case study for demography. The evolution of the age structure of the Umbrian population anticipated in a certain way the dynamics that later characterised the entire Italian population."
  },
  {
    "objectID": "projects/Umbria demografia/Index.html#piramidi-delle-età",
    "href": "projects/Umbria demografia/Index.html#piramidi-delle-età",
    "title": "Umbria - Principali indicatori demografici",
    "section": "Piramidi delle età",
    "text": "Piramidi delle età\nL’Umbria è una regione particolarmente anziana. Nel 2000 presentava, infatti, delle proporzioni di popolazione oltre ai 65 anni decisamente maggiori rispetto a quelle riscontrabili nell’interezza della popolazione italiana. Al 2024, la composizione per età della popolazione umbra ricalca più fedelmente quella nazionale. La forma della piramide risulta però sempre lievemente più spostata verso le età molto avanzate, a suggerire una sopravvivenza degli individui della terza età più elevata rispetto alla media nazionale.\n\n\nCodice\n## Italia ----\n### 2024\nit24gg &lt;- it24 |&gt; \n  filter(Sesso != 'Totale') |&gt;\n  ggplot(aes(x = Età,\n             y = ifelse(Sesso == 'M',\n                        -`Tot per genere`, `Tot per genere`),\n             fill = Sesso)) +\n  geom_bar(stat = 'identity', width = 1) +\n  coord_flip() +\n  scale_fill_manual(values = c('#A4D1CA', '#148068')) +\n  labs(title = 'Italia 2024')\n  \nit00gg &lt;- it00 |&gt; \n  filter(Sesso != 'Totale') |&gt; \n  ggplot(aes(x = Età,\n             y = ifelse(Sesso == 'M',\n                        -`2000`, `2000`),\n             fill = Sesso)) +\n  geom_bar(stat = 'identity', width = 1) +\n  coord_flip() +\n  scale_fill_manual(values = c('#A4D1CA', '#148068')) +\n  labs(title = 'Italia 2000')\n\n## Umbria ----\n### 2024\num24gg &lt;- um24 |&gt; \n  filter(Sesso != 'Totale') |&gt;\n  ggplot(aes(x = Età,\n             y = ifelse(Sesso == 'M',\n                        -`Tot per genere`, `Tot per genere`),\n             fill = Sesso)) +\n  geom_bar(stat = 'identity', width = 1) +\n  coord_flip() +\n  scale_fill_manual(values = c('#A4D1CA', '#148068')) +\n  labs(title = 'Umbria 2024')\n\num00gg &lt;- um00 |&gt; \n  filter(Sesso != 'Totale') |&gt; \n  ggplot(aes(x = Età,\n             y = ifelse(Sesso == 'M',\n                        -`2000`, `2000`),\n             fill = Sesso)) +\n  geom_bar(stat = 'identity', width = 1) +\n  coord_flip() +\n  scale_fill_manual(values = c('#A4D1CA', '#148068')) +\n  labs(title = 'Umbria 2000')\n\n## Patchwork ----\nit00gg + um00gg + it24gg + um24gg +\n  plot_layout(guides = 'collect', axes = 'collect') +\n  plot_annotation(title = 'Piramidi delle età',\n                  caption = 'Dati Demo.Istat',\n                  theme = theme(plot.title = element_text(size = 18))) &\n  theme(legend.position = 'bottom',\n        axis.title.x = element_blank(),\n        # axis.text.x = element_blank(),\n        # axis.ticks.x = element_blank(),\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        plot.title.position = 'panel')"
  },
  {
    "objectID": "projects/Umbria demografia/Index.html#indici-di-popolazione",
    "href": "projects/Umbria demografia/Index.html#indici-di-popolazione",
    "title": "Umbria - Principali indicatori demografici",
    "section": "Indici di popolazione",
    "text": "Indici di popolazione\nLa particolare anzianità della popolazione umbra si riscontra immediatamente confrontando l’età media regionale con quella dell’Italia intera nell’ultimo venticinquennio: anche a netto di una tendenza generalizzata all’invecchiamento, la differenza tra il valore regionale e la media nazionale rimane sempre positiva. Notevole è però il fatto che l’Umbria sia nell’atto di essere raggiunta dal resto del Paese, con una diminuzione della distanza tra i due valori medi totali da 2,78 a 1,55 anni. Si noti che l’età media della popolazione femminile è sempre maggiore di quella maschile. Questo è principalmente dovuto a una maggiore sopravvivenza femminile in età avanzata, come riscontrabile analizzando le piramidi delle età di cui sopra.\n\n\nCodice\ngirafe(ggobj = etadf |&gt;\n  mutate(Anno = anno,\n         'Territorio' = geo,\n         'Femmine' = round(etaMed_F, 2),\n         'Maschi' = round(etaMed_M, 2),\n         'Totale' = round(etaMed_Totale, 2),\n         'Giovanile' = round(dipGiov, 2),\n         'Vecchiaia' = round(dipVec, 2),\n         'Complessivo' = round(dip, 2),\n         'Indice di vecchiaia' = round(vec, 2),\n         'Rapporto di mascolinità' = round(rapMasc, 2)\n         ) |&gt; \n  select(Anno, Territorio, Femmine, Maschi, Totale) |&gt; \n  pivot_longer(cols = c(Femmine, Maschi, Totale)) |&gt; \n  ggplot(aes(x = name, y = value, fill = factor(Anno), dataid = value, tooltip = value)) +\n  geom_col_interactive(position = 'dodge', width = .6) +\n  geom_hline(yintercept = 0) +\n  geom_text(aes(y = 2, label = name), hjust = 0, col = 'white') +\n  coord_flip() +\n  labs(title = 'Età medie',\n       caption = 'Dati Demo.Istat') +\n  scale_fill_manual(values = c('#A4D1CA', '#148068')) +\n  scale_y_continuous(expand = c(0, 0)) +\n  facet_wrap(~Territorio) +\n  theme(legend.position = 'bottom',\n        axis.title = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank(),\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        strip.background = element_blank(),\n        plot.title.position = 'panel',\n        panel.grid.major.x = element_line(color = \"#A8BAC4\", size = 0.3)),\n  options = list(\n         opts_tooltip(css = 'background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\n                      background:rgba(255, 255, 255, 0.8);'),\n         opts_hover(css = ''),\n         opts_hover_inv(css = \"opacity:0.3;\"),\n         opts_toolbar(hidden = c('selection', 'zoom', 'misc'))))\n\n\n\n\n\n\nLa composizione per età dell’Umbria ha anche un effetto tangibile sugli indici di dipendenza: se quello giovanile è più basso sia nel 2000 che nel 2024, quello di vecchiaia è sempre superiore all’indice calcolato sulla popolazione nazionale. L’inclemente risultato è quello di un indice di dipendenza complessivo sempre superiore alla media nazionale, con un potenziale effetto deleterio sul tessuto produttivo regionale. L’indice di vecchiaia mostra in maniera ancora più drammatica lo squilibrio tra la popolazione anziana e quella in età pre-lavorativa.\n\n\nCodice\ngirafe(ggobj = etadf |&gt;\n  mutate(Anno = anno,\n         'Territorio' = geo,\n         'Femmine' = round(etaMed_F, 2),\n         'Maschi' = round(etaMed_M, 2),\n         'Totale' = round(etaMed_Totale, 2),\n         'Giovanile' = round(dipGiov, 2),\n         'Vecchiaia' = round(dipVec, 2),\n         'Complessivo' = round(dip, 2),\n         'Indice di vecchiaia' = round(vec, 2),\n         'Rapporto di mascolinità' = round(rapMasc, 2)\n         ) |&gt; \n  select(Anno, Territorio, Giovanile, Vecchiaia, Complessivo) |&gt; \n  pivot_longer(cols = c(Giovanile, Vecchiaia, Complessivo)) |&gt; \n  ggplot(aes(x = name, y = value, fill = factor(Anno), dataid = value, tooltip = value)) +\n  geom_col_interactive(position = 'dodge', width = .6) +\n  geom_hline(yintercept = 0) +\n  geom_text(aes(y = .02, label = name), hjust = 0, col = 'white') +\n  coord_flip() +\n  labs(title = 'Indici di indipendenza',\n       caption = 'Dati Demo.Istat') +\n  scale_fill_manual(values = c('#A4D1CA', '#148068')) +\n  scale_y_continuous(expand = c(0, 0)) +\n  facet_wrap(~Territorio) +\n  theme(legend.position = 'bottom',\n        axis.title = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks.y = element_blank(),\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        strip.background = element_blank(),\n        plot.title.position = 'panel',\n        panel.grid.major.x = element_line(color = \"#A8BAC4\", size = 0.3)),\n  options = list(\n         opts_tooltip(css = 'background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\n                      background:rgba(255, 255, 255, 0.8);'),\n         opts_hover(css = ''),\n         opts_hover_inv(css = \"opacity:0.3;\"),\n         opts_toolbar(hidden = c('selection', 'zoom', 'misc'))))\n\n\n\n\n\n\nAlcune ultime considerazioni riguardano il rapporto di mascolinità. Sia quando calcolato sull’intera popolazione italiana, sia quando ristretto solamente alla regione Umbria, questo indicatore presenta uno squilibrio verso i maschi ad età zero ed uno verso le femmine nella popolazione totale. Questo significa che se è vero che nascono più uomini che donne, è anche vero che i primi tendono ad essere eliminati più facilmente dalla mortalità, portando il rapporto a pendere verso le seconde.\n\n\nCodice\netadf |&gt;\n  mutate(Anno = anno,\n         'Territorio' = geo,\n         'Femmine' = round(etaMed_F, 2),\n         'Maschi' = round(etaMed_M, 2),\n         'Totale' = round(etaMed_Totale, 2),\n         'Giovanile' = round(dipGiov, 2),\n         'Vecchiaia' = round(dipVec, 2),\n         'Complessivo' = round(dip, 2),\n         'Indice di vecchiaia' = round(vec, 2),\n         'Popolazione' = round(rapMasc, 2),\n         'Età 0' = round(rapMasc0, 2)\n  ) |&gt; \n  select(Territorio, Femmine, Maschi, Totale, Giovanile, Vecchiaia, Complessivo, `Indice di vecchiaia`, `Popolazione`, `Età 0`) |&gt; \n  gt(rowname_col = 'Territorio') |&gt; \n  tab_stubhead(\n    label = 'Anno'\n  ) |&gt; \n  tab_row_group(\n    label = '2000',\n    rows = c(1,3)\n  ) |&gt; \n  tab_row_group(\n    label = '2024',\n    rows = c(2,4)\n  ) |&gt; \n  tab_header(\n    title = md('## Indici di popolazione'),\n    subtitle = md('Per **anno** e **territorio**')\n  ) |&gt; \n  tab_spanner(\n    label = 'Età media',\n    columns = c(Femmine, Maschi, Totale)\n  ) |&gt; \n  tab_spanner(\n    label = 'Indice di dipendenza',\n    columns = c(Giovanile, Vecchiaia, `Complessivo`)\n  ) |&gt; \n  tab_spanner(\n    label = 'Rapporto di mascolinità',\n    columns = c(Popolazione, `Età 0`)\n  ) |&gt; \n  tab_source_note(\n    source_note = 'Dati Demo.Istat'\n  ) |&gt; \n  cols_align(\n    align = 'center',\n    columns = 3:10\n  ) |&gt;\n  cols_align(\n    align = 'left',\n    columns = 1:2\n  ) |&gt; \n  tab_options(table.background.color = 'white',\n              table.font.style = 'Roboto',\n              table.border.top.color = 'white',\n              heading.align = 'center',\n              row.striping.include_stub =FALSE,\n              heading.border.bottom.color = \"white\",\n              row_group.border.bottom.color = \"white\",\n              row_group.border.top.color = \"white\"\n              )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIndici di popolazione\nIndici di popolazione\n\n\n\nPer anno e territorio\n\n\nAnno\n\nEtà media\n\n\nIndice di dipendenza\n\nIndice di vecchiaia\n\nRapporto di mascolinità\n\n\n\nFemmine\nMaschi\nTotale\nGiovanile\nVecchiaia\nComplessivo\nPopolazione\nEtà 0\n\n\n\n\n2024\n\n\nItalia\n47.48\n44.67\n46.10\n0.19\n0.38\n0.58\n199.84\n95.73\n106.11\n\n\nUmbria\n49.08\n46.13\n47.65\n0.18\n0.44\n0.62\n237.93\n93.94\n105.51\n\n\n2000\n\n\nItalia\n42.40\n39.38\n40.94\n0.21\n0.27\n0.48\n126.59\n93.88\n105.44\n\n\nUmbria\n45.16\n42.18\n43.72\n0.19\n0.34\n0.53\n182.31\n93.59\n111.89\n\n\n\nDati Demo.Istat"
  },
  {
    "objectID": "projects/Umbria demografia/Index.html#saldi-migratori",
    "href": "projects/Umbria demografia/Index.html#saldi-migratori",
    "title": "Umbria - Principali indicatori demografici",
    "section": "Saldi migratori",
    "text": "Saldi migratori\nIn generale, l’andamento del saldo migratorio umbro va di pari passo con quello nazionale, caratterizzato da due picchi nel 2003 (in corrispondenza dell’introduzione della legge Bossi-Fini) e nel 2007 (anno di ulteriori sanatorie, contemporanee all’entrata della Romania nell’Unione Europea). È interessante l’avvallamento del saldo migratorio totale fra il 2018 e il 2020, indipendente dal saldo migratorio interno e da quello con l’estero. Il motivo di questo disacoppiamento è con tutta probabilità dovuto a problemi definitori e di conteggio: Il saldo migratorio con l’estero non tiene conto di alcuni specifici fenomeni emigratori, su tutti i rimpatri. Nel 2018, per mezzo dei decreti sicurezza, c’è stato un notevole aumento di questo tipo di evento demografico, che potrebbe aver contribuito a causare il disaccoppiamento di cui sopra, rientrato solamente nel 2022.\n\n\nCodice\ngirafe(ggobj = inddf |&gt; \n  filter(var == 'Saldo migratorio con l\\'estero' | var == 'Saldo migratorio interno' | var == 'Saldo migratorio') |&gt; \n  ggplot(aes(x = anno, y = value, dataid = anno, tooltip = value)) +\n  geom_point_interactive(alpha = 0) +\n  geom_line(data = ~. |&gt; filter(Territorio == 'Italia' & var != 'Saldo migratorio interno')\n            |&gt; filter(var == 'Saldo migratorio'), aes(linetype = var)) +\n  geom_line(data = ~. |&gt; filter(Territorio == 'Italia' & var != 'Saldo migratorio interno')\n            |&gt; filter(var != 'Saldo migratorio'), aes(col = var)) +\n  geom_line(data = ~. |&gt; filter(Territorio == 'Umbria')\n            |&gt; filter(var == 'Saldo migratorio'), aes(linetype = var)) +\n  geom_line(data = ~. |&gt; filter(Territorio == 'Umbria')\n            |&gt; filter(var != 'Saldo migratorio'), aes(col = var)) +\n  geom_line(data = ~. |&gt; filter(var != 'Saldo migratorio'), aes(col = var)) +\n  geom_hline(yintercept = 0, col = 'gray60') +\n  scale_x_continuous(breaks = c(2002, 2004, 2006, 2008, 2010, 2012, 2014, 2016, 2018, 2020, 2022, 2024)) +\n  scale_color_manual(values = c('#803014', '#148068')) +\n  scale_linetype_manual(values = 'dashed') +\n  labs(title = 'Saldi migratori',\n       subtitle = 'Serie storica 2002-2023',\n       caption = 'Dati Demo.Istat') +\n  facet_wrap(~Territorio) +\n  theme(legend.position = 'bottom',\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        plot.title = element_text(size = 18),\n        plot.subtitle = element_text(size = 12),\n        strip.background = element_blank(),\n        strip.text = element_text(size = 12),\n        axis.ticks = element_blank(),\n        axis.title = element_blank()),\n  options = list(\n         opts_tooltip(css = 'background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\n                      background:rgba(255, 255, 255, 0.8);'),\n         opts_hover(css = ''),\n         opts_hover_inv(css = \"opacity:0.3;\"),\n         opts_toolbar(hidden = c('selection', 'zoom', 'misc')))\n  )"
  },
  {
    "objectID": "projects/Umbria demografia/Index.html#tasso-di-fecondità-totale",
    "href": "projects/Umbria demografia/Index.html#tasso-di-fecondità-totale",
    "title": "Umbria - Principali indicatori demografici",
    "section": "Tasso di fecondità totale",
    "text": "Tasso di fecondità totale\nIl TFT delle madri straniere è generalmente molto più alto in termini assoluti. Anche in questo sottogruppo, però, rimane vera l’osservazione di cui sopra: il TFT calcolato sulle madri straniere in Umbria cala a ritmi sensibilmente maggiori rispetto al resto d’Italia.\n\n\nCodice\ngirafe(ggobj = fecdf |&gt; \n  filter(var == 'Tasso di fecondità totale, madri italiane'\n         | var == 'Tasso di fecondità totale, madri straniere'\n         | var == 'Tasso di fecondità totale, tutte le madri') |&gt; \n  mutate(var = gsub('Tasso di fecondità totale, m', 'M', var, fixed = T),\n         var = gsub('Tasso di fecondità totale, t', 'T', var, fixed = T)) |&gt; \n  ggplot(aes(x = anno, y = value, dataid = anno, tooltip = value)) +\n  geom_point_interactive(alpha = 0) +\n  geom_line(data = ~. |&gt; filter(var == 'Tutte le madri'), aes(linetype = var)) +\n  geom_line(data = ~. |&gt; filter(var != 'Tutte le madri'), aes(col = var)) +\n  labs(title = 'Tasso di fecondità totale') +\n  scale_x_continuous(breaks = c(2002, 2004, 2006, 2008, 2010, 2012, 2014, 2016, 2018, 2020, 2022, 2023)) +\n  scale_color_manual(values = c('#803014', '#148068')) +\n  scale_linetype_manual(values = 'dashed') +\n  labs(title = 'Tasso di fecondità totale',\n       subtitle = 'Serie storica 2002-2023',\n       caption = 'Dati Demo.Istat') +\n  facet_wrap(~Territorio) +\n  theme(legend.position = 'bottom',\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        strip.background = element_blank(),\n        plot.title = element_text(size = 18),\n        plot.subtitle = element_text(size = 12),\n        strip.text = element_text(size = 12),\n        axis.ticks = element_blank(),\n        axis.title = element_blank()),\n  options = list(\n         opts_tooltip(css = 'background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\n                      background:rgba(255, 255, 255, 0.8);'),\n         opts_hover(css = ''),\n         opts_toolbar(hidden = c('selection', 'zoom', 'misc'))\n  ))"
  },
  {
    "objectID": "projects/Umbria demografia/Index.html#età-media-al-parto",
    "href": "projects/Umbria demografia/Index.html#età-media-al-parto",
    "title": "Umbria - Principali indicatori demografici",
    "section": "Età media al parto",
    "text": "Età media al parto\nForse il fattore più importante per comprendere la differenza abissale fra i TFT di cittadine italiane e straniere è l’età al primo parto. Se è vero che esiste una generalizzata tendenza ad avere figli più tardi, le madri straniere partivano nel 2002 da livelli sensibilmente più bassi di questo indicatore (circa 27 anni contro gli oltre 30 delle madri italiane).\n\n\nCodice\ngirafe(ggobj = fecdf |&gt; \n  filter(Territorio == 'Umbria',\n         var == 'Età media al parto, madri italiane'\n         | var == 'Età media al parto, madri straniere'\n         | var == 'Età media al parto, tutte le madri') |&gt; \n  mutate(var = gsub('Età media al parto, m', 'M', var, fixed = T),\n         var = gsub('Età media al parto, t', 'T', var, fixed = T)) |&gt; \n  ggplot(aes(x = anno, y = value, dataid = anno, tooltip = value)) +\n  geom_point_interactive(alpha = 0) +\n  geom_line(data = ~. |&gt; filter(var == 'Tutte le madri'), aes(linetype = var)) +\n  geom_line(data = ~. |&gt; filter(var != 'Tutte le madri'), aes(col = var)) +\n  scale_color_manual(values = c('#803014', '#148068')) +\n  scale_linetype_manual(values = 'dashed') +\n  labs(title = 'Età media al parto',\n       subtitle = 'Serie storica 2002-2023') +\n  scale_x_continuous(breaks = c(2002, 2004, 2006, 2008, 2010, 2012, 2014, 2016, 2018, 2020, 2022, 2024)) +\n  facet_wrap(~Territorio) +\n  theme(legend.position = 'bottom',\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        plot.title = element_text(size = 18),\n        plot.subtitle = element_text(size = 12),\n        strip.background = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank()),\n  options = list(\n         opts_tooltip(css = 'background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\n                      background:rgba(255, 255, 255, 0.8);'),\n         opts_hover(css = ''),\n         opts_toolbar(hidden = c('selection', 'zoom', 'misc'))\n  ))\n\n\n\n\n\n\nLa differenza nell’età media al primo parto fra madri straniere ed italiane diventa ancora più evidente quando si analizza la distribuzione degli indici specifici di fecondità sull’asse delle età. Nonostante sia chiaramente visibile un avvicinamento fra le due categorie, le due distribuzioni differiscono fortemente per forma e posizione: quella individuata dalle età delle madri straniere ha una media chiaramente minore e presenta una maggiore curtosi verso destra.\n\n\nCodice\ngirafe(ggobj = FX |&gt;\n  filter(`Anno di evento` == 2013 | `Anno di evento` == 2023) |&gt; \n  ggplot(aes(x = Età, y = FX, col = citt, dataid = Età, tooltip = FX)) +\n  geom_point_interactive(alpha = 0) +\n  geom_line() +\n  facet_wrap(~`Anno di evento`) +\n  scale_color_manual(values = c('#803014', '#148068')) +\n  labs(title = 'Tassi specifici di fecondità per età',\n       subtitle = 'Regione Umbria',\n       caption = 'Dati Demo.Istat') +\n  theme(legend.position = 'bottom',\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        plot.subtitle = element_text(size = 12),\n        plot.title = element_text(size = 18),\n        strip.background = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank()),\n  options = list(\n         opts_tooltip(css = 'background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\n                      background:rgba(255, 255, 255, 0.8);'),\n         opts_hover(css = ''),\n         opts_toolbar(hidden = c('selection', 'zoom', 'misc'))\n  ))"
  },
  {
    "objectID": "projects/Umbria demografia/Index.html#speranza-di-vita-e-mortalità",
    "href": "projects/Umbria demografia/Index.html#speranza-di-vita-e-mortalità",
    "title": "Umbria - Principali indicatori demografici",
    "section": "Speranza di vita e mortalità",
    "text": "Speranza di vita e mortalità\nL’evoluzione recente degli indicatori di mortalità restituisce una fotografia dello stadio finale del processo di transizione demografica: la speranza di vita alla nascita e a 65 anni cresce fino a stabilizzarsi su livelli molto alti, la probabilità di morte alla nascita crolla sotto al 2,5%. È notevole lo shock in termini di mortalità causato dalla pandemia di COVID-19: nel 2020 speranza di vita e probabilità di morte balzano indietro ai livelli dei due anni precedenti, soprattutto nella popolazione maschile.\n\n\nCodice\n## Speranza di vita alla nascita per sesso\numbe0 &lt;- umbMort |&gt; \n  filter(Sesso == 'Maschi' & Età == 0 | Sesso == 'Femmine' & Età == 0) |&gt; \n  ggplot(aes(x = anno, y = `Speranza di vita`, col = Sesso,\n             dataid = anno, tooltip = `Speranza di vita`)) +\n  geom_path(aes(group = Sesso)) +\n  scale_color_manual(values = c('#803014', '#148068')) +\n  labs(title = 'Speranza di vita alla nascita') +\n  theme(legend.position = 'bottom',\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank())\n\n## Speranza di vita a 65 anni per sesso\numbe65 &lt;- umbMort |&gt; \n  filter(Sesso == 'Maschi' & Età == 65 | Sesso == 'Femmine' & Età == 65) |&gt; \n  ggplot(aes(x = anno, y = `Speranza di vita`, col = Sesso,\n             dataid = anno, tooltip = `Speranza di vita`)) +\n  geom_path(aes(group = Sesso)) +\n  scale_color_manual(values = c('#803014', '#148068')) +\n  labs(title = 'Speranza di vita a 65 anni') +\n  theme(legend.position = 'bottom',\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank())\n\n## Probabilità di morte alla nascita per sesso\numbq0 &lt;- umbMort |&gt; \n  filter(Sesso == 'Maschi' & Età == 0 | Sesso == 'Femmine' & Età == 0) |&gt; \n  ggplot(aes(x = anno, y = `Probabilità di morte (per mille)`,\n             col = Sesso, dataid = anno, tooltip = `Probabilità di morte (per mille)`)) +\n  geom_path(aes(group = Sesso)) +\n  scale_color_manual(values = c('#803014', '#148068')) +\n  labs(title = 'Probabilità di morte alla nascita') +\n  theme(legend.position = 'bottom',\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank())\n\n## Patchwork\n### Umbria\ngirafe(ggobj = umbe0 + umbe65 + umbq0 +\n  plot_layout(guides = 'collect', axes = 'collect') +\n  plot_annotation(caption = 'Regione Umbria, Dati Demo.Istat',\n                  theme = theme(plot.title = element_text(size = 18),\n        plot.subtitle = element_text(size = 12),)) & theme(legend.position = 'bottom'),\n  options = list(\n         opts_tooltip(css = 'background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\n                      background:rgba(255, 255, 255, 0.8);'),\n         opts_hover(css = ''),\n         opts_hover_inv(css = \"opacity:0.3;\"),\n         opts_toolbar(hidden = c('selection', 'zoom', 'misc')))\n)"
  },
  {
    "objectID": "projects/Umbria demografia/Index.html#sopravviventi-per-anno",
    "href": "projects/Umbria demografia/Index.html#sopravviventi-per-anno",
    "title": "Umbria - Principali indicatori demografici",
    "section": "Sopravviventi per anno",
    "text": "Sopravviventi per anno\nLa sconfitta della mortalità è ulteriormente esemplificata dalla rappresentazione della curva di sopravviventi per anno, che approssima sempre più un rettangolo. Al diminuire della probabilità di morte nella terza età, il numero di sopravviventi rimane essenzialmente costante fino a molto tardi. Le curve sembrano avvicinarsi anno dopo anno ad una sorta di limite naturale della vita umana, età a cui la probabilità di morte decolla e i sopravviventi diminuiscono drasticamente.\n\n\nCodice\n### Umbria ----\numbMort |&gt; \n  filter(Sesso != 'Maschi e femmine') |&gt; \n  filter(anno == 1974 | anno == 1994 | anno == 2014) |&gt;\n  ggplot(aes(x = Età, y = Sopravviventi, linetype = anno, group = anno)) +\n  geom_line() +\n  facet_wrap(~Sesso) +\n  scale_color_manual(values = c('#803014', '#148068')) +\n  labs(title = 'Curva di sopravviventi per anno',\n       subtitle = 'Regione Umbria',\n       caption = 'Dati Demo.Istat') +\n  theme(legend.position = 'bottom',\n        plot.title = element_text(size = 18),\n        plot.subtitle = element_text(size = 12),\n        strip.text = element_text(size = 12),\n        panel.background = element_blank(),\n        panel.grid = element_line(colour = 'gray90'),\n        legend.title = element_blank(),\n        strip.background = element_blank(),\n        axis.ticks = element_blank(),\n        axis.title = element_blank())"
  },
  {
    "objectID": "projects/UmbriaPress corpus/index.html",
    "href": "projects/UmbriaPress corpus/index.html",
    "title": "UmbriaPress Corpus",
    "section": "",
    "text": "UmbriaPress is a corpus of press releases by three major news outlets in Umbria: Corriere dell’Umbria, PerugiaToday, Terninrete.\nExpected use cases are:\nThe complete corpus can be downloaded at this link. All resources (including the source code for the scrapers and the visualisation below) are available by clicking on the Code box at the top of this page."
  },
  {
    "objectID": "projects/UmbriaPress corpus/index.html#corpus-description",
    "href": "projects/UmbriaPress corpus/index.html#corpus-description",
    "title": "UmbriaPress Corpus",
    "section": "Corpus description",
    "text": "Corpus description\nThe articles are categorised by city (Terni/Perugia) and time stamped. Since PerugiaToday assigns a main tag to each article, I decided to include those as well in the dataset.\nThe corpus amounts to a grand total of 168,528 articles. It is, however, rather diverse (thus potentially biased) in terms of regional coverage and language type. The two “fast journalism” outlets (PerugiaToday, Terninrete) completely flood the corpus, making the more traditionally managed Corriere dell’Umbria basically invisible. Perugia is vastly overrepresented, and there is a visible bias towards more recent articles.\nBelow, an interactive visualisation of the corpus’ composition:"
  },
  {
    "objectID": "projects/RxR Report inequality and poverty/index.html",
    "href": "projects/RxR Report inequality and poverty/index.html",
    "title": "Inequality and poverty report",
    "section": "",
    "text": "Show code\npackages &lt;- c('ggbump','tidyverse','laeken','MetBrewer','sf','ggiraph')\ninstall.packages(setdiff(packages, rownames(installed.packages()))) \nrm(packages)\nlibrary(ggbump)\nlibrary(tidyverse)\nlibrary(laeken)\nlibrary(MetBrewer)\nlibrary(sf)\nlibrary(ggiraph)\n# import pdata\npdata &lt;- readRDS('SHIWpdata.rds')\n# Inequality indexes -----------------------------------------------------------\n## Gini - Income ----\n### Over regions by year\nas_tibble(gini(pdata$eqhincome,\n     weights = pdata$peso,\n     years = pdata$anno,\n     breakdown = pdata$ireg,\n     na.rm = T\n)[['valueByStratum']]) -&gt; giniInc\n\nginiInc$stratum &lt;- gsub(' - ', '-', giniInc$stratum)\n### ranking\nginiInc |&gt; \n  group_by(year) |&gt; \n  mutate(\n    rank = rank(value)\n  ) -&gt; giniInc\n### rounding off value\nginiInc$value &lt;- round(giniInc$value, 2)\n\n### ranking5\nginiInc$rank5 &lt;- case_match(giniInc$rank,\n                            1:4 ~ 1,\n                            5:8 ~ 2,\n                            9:12 ~ 3,\n                            13:16 ~ 4,\n                            17:20 ~ 5\n                            )\n### Total by year\nas_tibble_col(gini(pdata$eqhincome,\n     weights = pdata$peso,\n     years = pdata$anno,\n     na.rm = T\n)[[\"value\"]]) -&gt; giniIncTot\n\nginiIncTot$stratum &lt;- 'Italia'\nginiIncTot$year &lt;- c(2000, 2002, 2004, 2008, 2010, 2012, 2014, 2016, 2020)\nginiIncTot$rank &lt;- NA\n\nginiInc &lt;- rbind(giniInc, giniIncTot)\nrm(giniIncTot)\n\n\n## Gini - wealth ----\n### Over regions by year\nas_tibble(gini(pdata$pcwealth,\n               weights = pdata$peso,\n               years = pdata$anno,\n               breakdown = pdata$ireg,\n               na.rm = T\n)[['valueByStratum']]) -&gt; giniW\n\nginiW$stratum &lt;- gsub(' - ', '-', giniW$stratum)\n\n### ranking\nginiW |&gt; \n  group_by(year) |&gt; \n  mutate(\n    rank = rank(value)\n  ) -&gt; giniW\n### ranking5\nginiW$rank5 &lt;- case_match(giniW$rank,\n                            1:4 ~ 1,\n                            5:8 ~ 2,\n                            9:12 ~ 3,\n                            13:16 ~ 4,\n                            17:20 ~ 5\n)\n\n### rounding off value\nginiW$value &lt;- round(giniW$value, 2)\n\n### Total by year\nas_tibble_col(gini(pdata$pcwealth,\n                   weights = pdata$peso,\n                   years = pdata$anno,\n                   na.rm = T\n)[[\"value\"]]) -&gt; giniWTot\n\nginiWTot$stratum &lt;- 'Italia'\nginiWTot$year &lt;- c(2000, 2002, 2004, 2008, 2010, 2012, 2014, 2016, 2020)\nginiWTot$rank &lt;- NA\n\nginiW &lt;- rbind(giniW, giniWTot)\nrm(giniWTot)\n\n\n\n# Poverty  ---------------------------------------------------------------------\n\n## Head count ----\n### Over region by year\npdata |&gt; \n  group_by(anno, ireg) |&gt; \n  count(pov) -&gt; pov\npdata |&gt; \n  group_by(anno, ireg) |&gt; \n  count(!pov) -&gt; pov$'!pov'\npov |&gt; \n  mutate('!pov' = `!pov`$n) |&gt; \n  filter(pov == 1) |&gt; \n  mutate(pov = n) |&gt; \n  select(!n) -&gt; pov\n\npov |&gt; \n  mutate(hCount = pov/(sum(pov, `!pov`))) -&gt; pov\n\n### Ranking\npov |&gt; \n  group_by(anno) |&gt; \n  mutate(\n    rankHCount = 21-rank(hCount)\n  ) -&gt; pov\n\n## Poverty intensity ----\n### povLine\npdata |&gt; \n  group_by(anno) |&gt; \n  summarise(povLine = weightedMedian(eqhincome,\n                                     weights = peso)*0.6) -&gt; povLine\npov &lt;- left_join(pov, povLine)\nrm(povLine)\n\n### Poverty gap\navPoor &lt;- pdata |&gt;\n  filter(pov == 1) |&gt; \n  group_by(anno, ireg) |&gt;\n  summarise(avPoor = weightedMean(eqhincome, weights = peso))\npov &lt;- left_join(pov, avPoor)\nrm(avPoor)\npov$povGapIndex &lt;- pov$hCount * (pov$povLine - pov$avPoor)/pov$povLine\n\n### Ranking\npov |&gt; \n  group_by(anno) |&gt; \n  mutate(\n    rankPovGap = 21-rank(povGapIndex)\n  ) -&gt; pov\n\n## LPM risk of being in poverty ----\npdata &lt;- within(pdata, cfedu &lt;- relevel(factor(cfedu), ref = 'Specializzazione post-laurea'))\npdata &lt;- within(pdata, cfsex &lt;- relevel(factor(cfsex), ref = 'Maschile'))\npdataReg &lt;- pdata |&gt; \n  filter(anno == 2020)\n\n### Regression models\nlpm0 &lt;- lm(pov ~ factor(cfedu),\n   weights = pesopop,\n   data = pdataReg)\nlpm1 &lt;- lm(pov ~ factor(cfedu) + factor(cfsex) + factor(cfclass),\n           weights = pesopop,\n           data = pdataReg)\n\n### Harvesting results\nlpm0results &lt;- as_tibble(summary(lpm0)[[\"coefficients\"]])\nlpm0results &lt;- cbind(lpm0results, confint(lpm0, level=0.95)) #adding CIs\n\nlpm1results &lt;- as_tibble(summary(lpm1)[[\"coefficients\"]])\nlpm1results &lt;- cbind(lpm1results, confint(lpm1, level=0.95)) #adding CIs\nlpm0results &lt;- lpm0results %&gt;% setNames(paste0('0.', names(.)))\n\n### Cleaning results\nlpm0results &lt;- lpm0results |&gt; \n  rownames_to_column(var = 'reg')\nlpm1results &lt;- lpm1results |&gt; \n  rownames_to_column(var = 'reg')\n\nlpmresults &lt;- full_join(lpm0results, lpm1results)\nrm(lpm0results, lpm1results, lpm0, lpm1)\n\nlpmresults['reg'][lpmresults['reg'] == '(Intercept)'] &lt;- ')Intercept'\n\nlpmresults &lt;- lpmresults |&gt; \n  mutate(reg = str_split_fixed(reg, fixed(')'), n = Inf)) \n\nlpmresults &lt;- within(lpmresults, reg &lt;- reg[,2])\n\nlpmresults$'0.star' &lt;- ifelse(lpmresults$`0.Pr(&gt;|t|)` &lt;= 0.001, '***',\n                            ifelse(lpmresults$`0.Pr(&gt;|t|)` &lt;= 0.01, '**',\n                                   ifelse(lpmresults$`0.Pr(&gt;|t|)` &lt;= 0.05, '*',\n                                          ifelse(lpmresults$`0.Pr(&gt;|t|)` &lt;= 0.1, '.', ''))))\n\nlpmresults$star&lt;- ifelse(lpmresults$`Pr(&gt;|t|)` &lt;= 0.001, '***',\n                              ifelse(lpmresults$`Pr(&gt;|t|)` &lt;= 0.01, '**',\n                                     ifelse(lpmresults$`Pr(&gt;|t|)` &lt;= 0.05, '*',\n                                            ifelse(lpmresults$`Pr(&gt;|t|)` &lt;= 0.1, '.', ''))))\n\nlpmresults &lt;- lpmresults |&gt; \n  relocate('0.star', .before = Estimate)\n\nlpmresults$vars &lt;- c('Intercetta', 'Titolo di studio', 'Titolo di studio', 'Titolo di studio', 'Titolo di studio', 'Titolo di studio', 'Sesso', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale')\n\n\nRxR - una Regione per Restare commissioned a research project on economic inequality in Italy, with a specific focus Umbria, its main region of interest. The complete report is available at forthcoming (in Italian), while the source code is available on github.\nBelow is a selection of the data visualization work involved (translated to English). The project was conducted using R, interactive plots and maps are realised using the ggiraph package."
  },
  {
    "objectID": "projects/RxR Report inequality and poverty/index.html#introduction",
    "href": "projects/RxR Report inequality and poverty/index.html#introduction",
    "title": "Inequality and poverty report",
    "section": "",
    "text": "Show code\npackages &lt;- c('ggbump','tidyverse','laeken','MetBrewer','sf','ggiraph')\ninstall.packages(setdiff(packages, rownames(installed.packages()))) \nrm(packages)\nlibrary(ggbump)\nlibrary(tidyverse)\nlibrary(laeken)\nlibrary(MetBrewer)\nlibrary(sf)\nlibrary(ggiraph)\n# import pdata\npdata &lt;- readRDS('SHIWpdata.rds')\n# Inequality indexes -----------------------------------------------------------\n## Gini - Income ----\n### Over regions by year\nas_tibble(gini(pdata$eqhincome,\n     weights = pdata$peso,\n     years = pdata$anno,\n     breakdown = pdata$ireg,\n     na.rm = T\n)[['valueByStratum']]) -&gt; giniInc\n\nginiInc$stratum &lt;- gsub(' - ', '-', giniInc$stratum)\n### ranking\nginiInc |&gt; \n  group_by(year) |&gt; \n  mutate(\n    rank = rank(value)\n  ) -&gt; giniInc\n### rounding off value\nginiInc$value &lt;- round(giniInc$value, 2)\n\n### ranking5\nginiInc$rank5 &lt;- case_match(giniInc$rank,\n                            1:4 ~ 1,\n                            5:8 ~ 2,\n                            9:12 ~ 3,\n                            13:16 ~ 4,\n                            17:20 ~ 5\n                            )\n### Total by year\nas_tibble_col(gini(pdata$eqhincome,\n     weights = pdata$peso,\n     years = pdata$anno,\n     na.rm = T\n)[[\"value\"]]) -&gt; giniIncTot\n\nginiIncTot$stratum &lt;- 'Italia'\nginiIncTot$year &lt;- c(2000, 2002, 2004, 2008, 2010, 2012, 2014, 2016, 2020)\nginiIncTot$rank &lt;- NA\n\nginiInc &lt;- rbind(giniInc, giniIncTot)\nrm(giniIncTot)\n\n\n## Gini - wealth ----\n### Over regions by year\nas_tibble(gini(pdata$pcwealth,\n               weights = pdata$peso,\n               years = pdata$anno,\n               breakdown = pdata$ireg,\n               na.rm = T\n)[['valueByStratum']]) -&gt; giniW\n\nginiW$stratum &lt;- gsub(' - ', '-', giniW$stratum)\n\n### ranking\nginiW |&gt; \n  group_by(year) |&gt; \n  mutate(\n    rank = rank(value)\n  ) -&gt; giniW\n### ranking5\nginiW$rank5 &lt;- case_match(giniW$rank,\n                            1:4 ~ 1,\n                            5:8 ~ 2,\n                            9:12 ~ 3,\n                            13:16 ~ 4,\n                            17:20 ~ 5\n)\n\n### rounding off value\nginiW$value &lt;- round(giniW$value, 2)\n\n### Total by year\nas_tibble_col(gini(pdata$pcwealth,\n                   weights = pdata$peso,\n                   years = pdata$anno,\n                   na.rm = T\n)[[\"value\"]]) -&gt; giniWTot\n\nginiWTot$stratum &lt;- 'Italia'\nginiWTot$year &lt;- c(2000, 2002, 2004, 2008, 2010, 2012, 2014, 2016, 2020)\nginiWTot$rank &lt;- NA\n\nginiW &lt;- rbind(giniW, giniWTot)\nrm(giniWTot)\n\n\n\n# Poverty  ---------------------------------------------------------------------\n\n## Head count ----\n### Over region by year\npdata |&gt; \n  group_by(anno, ireg) |&gt; \n  count(pov) -&gt; pov\npdata |&gt; \n  group_by(anno, ireg) |&gt; \n  count(!pov) -&gt; pov$'!pov'\npov |&gt; \n  mutate('!pov' = `!pov`$n) |&gt; \n  filter(pov == 1) |&gt; \n  mutate(pov = n) |&gt; \n  select(!n) -&gt; pov\n\npov |&gt; \n  mutate(hCount = pov/(sum(pov, `!pov`))) -&gt; pov\n\n### Ranking\npov |&gt; \n  group_by(anno) |&gt; \n  mutate(\n    rankHCount = 21-rank(hCount)\n  ) -&gt; pov\n\n## Poverty intensity ----\n### povLine\npdata |&gt; \n  group_by(anno) |&gt; \n  summarise(povLine = weightedMedian(eqhincome,\n                                     weights = peso)*0.6) -&gt; povLine\npov &lt;- left_join(pov, povLine)\nrm(povLine)\n\n### Poverty gap\navPoor &lt;- pdata |&gt;\n  filter(pov == 1) |&gt; \n  group_by(anno, ireg) |&gt;\n  summarise(avPoor = weightedMean(eqhincome, weights = peso))\npov &lt;- left_join(pov, avPoor)\nrm(avPoor)\npov$povGapIndex &lt;- pov$hCount * (pov$povLine - pov$avPoor)/pov$povLine\n\n### Ranking\npov |&gt; \n  group_by(anno) |&gt; \n  mutate(\n    rankPovGap = 21-rank(povGapIndex)\n  ) -&gt; pov\n\n## LPM risk of being in poverty ----\npdata &lt;- within(pdata, cfedu &lt;- relevel(factor(cfedu), ref = 'Specializzazione post-laurea'))\npdata &lt;- within(pdata, cfsex &lt;- relevel(factor(cfsex), ref = 'Maschile'))\npdataReg &lt;- pdata |&gt; \n  filter(anno == 2020)\n\n### Regression models\nlpm0 &lt;- lm(pov ~ factor(cfedu),\n   weights = pesopop,\n   data = pdataReg)\nlpm1 &lt;- lm(pov ~ factor(cfedu) + factor(cfsex) + factor(cfclass),\n           weights = pesopop,\n           data = pdataReg)\n\n### Harvesting results\nlpm0results &lt;- as_tibble(summary(lpm0)[[\"coefficients\"]])\nlpm0results &lt;- cbind(lpm0results, confint(lpm0, level=0.95)) #adding CIs\n\nlpm1results &lt;- as_tibble(summary(lpm1)[[\"coefficients\"]])\nlpm1results &lt;- cbind(lpm1results, confint(lpm1, level=0.95)) #adding CIs\nlpm0results &lt;- lpm0results %&gt;% setNames(paste0('0.', names(.)))\n\n### Cleaning results\nlpm0results &lt;- lpm0results |&gt; \n  rownames_to_column(var = 'reg')\nlpm1results &lt;- lpm1results |&gt; \n  rownames_to_column(var = 'reg')\n\nlpmresults &lt;- full_join(lpm0results, lpm1results)\nrm(lpm0results, lpm1results, lpm0, lpm1)\n\nlpmresults['reg'][lpmresults['reg'] == '(Intercept)'] &lt;- ')Intercept'\n\nlpmresults &lt;- lpmresults |&gt; \n  mutate(reg = str_split_fixed(reg, fixed(')'), n = Inf)) \n\nlpmresults &lt;- within(lpmresults, reg &lt;- reg[,2])\n\nlpmresults$'0.star' &lt;- ifelse(lpmresults$`0.Pr(&gt;|t|)` &lt;= 0.001, '***',\n                            ifelse(lpmresults$`0.Pr(&gt;|t|)` &lt;= 0.01, '**',\n                                   ifelse(lpmresults$`0.Pr(&gt;|t|)` &lt;= 0.05, '*',\n                                          ifelse(lpmresults$`0.Pr(&gt;|t|)` &lt;= 0.1, '.', ''))))\n\nlpmresults$star&lt;- ifelse(lpmresults$`Pr(&gt;|t|)` &lt;= 0.001, '***',\n                              ifelse(lpmresults$`Pr(&gt;|t|)` &lt;= 0.01, '**',\n                                     ifelse(lpmresults$`Pr(&gt;|t|)` &lt;= 0.05, '*',\n                                            ifelse(lpmresults$`Pr(&gt;|t|)` &lt;= 0.1, '.', ''))))\n\nlpmresults &lt;- lpmresults |&gt; \n  relocate('0.star', .before = Estimate)\n\nlpmresults$vars &lt;- c('Intercetta', 'Titolo di studio', 'Titolo di studio', 'Titolo di studio', 'Titolo di studio', 'Titolo di studio', 'Sesso', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale', 'Settore economico dell\\'occupazione principale')\n\n\nRxR - una Regione per Restare commissioned a research project on economic inequality in Italy, with a specific focus Umbria, its main region of interest. The complete report is available at forthcoming (in Italian), while the source code is available on github.\nBelow is a selection of the data visualization work involved (translated to English). The project was conducted using R, interactive plots and maps are realised using the ggiraph package."
  },
  {
    "objectID": "projects/RxR Report inequality and poverty/index.html#mapping-inequality-and-poverty",
    "href": "projects/RxR Report inequality and poverty/index.html#mapping-inequality-and-poverty",
    "title": "Inequality and poverty report",
    "section": "Mapping inequality and poverty",
    "text": "Mapping inequality and poverty\n\n\nShow code\n##### import sf\nregMap &lt;- readRDS('regMap.rds')\n\n##### merge Gini tibbles with sf data\nincMap &lt;- left_join(giniInc, regMap, by = join_by(stratum == DEN_REG))\n\n##### ggiraph ready map\nincGiniGG &lt;- incMap |&gt; \n  filter(year == 2000 | year == 2010 |year == 2020) |&gt; \n  drop_na(rank) |&gt; \n  ggplot() +\n  geom_sf_interactive(aes(geometry = geometry, fill = value, data_id = stratum, tooltip = value), colour = 'black') +\n  facet_wrap(vars(year)) +\n  labs(x = NULL, y = NULL,\n       title = 'Gini index by region',\n       subtitle = 'Equivalent household income',\n       caption = 'Data: Bank of Italy. Elaborated by Lorenzo Mattioli - Una Regione per Restare') +\n  theme_minimal(base_family = 'Helvetica') +\n  scale_fill_viridis_c(direction = -1, limits = c(15, 40), option = 'mako') +\n  theme(axis.text.x=element_blank(),\n        axis.ticks.x=element_blank(),\n        axis.text.y=element_blank(),\n        axis.ticks.y=element_blank(),\n        panel.grid = element_blank(),\n        legend.title = element_blank(),\n        plot.title = element_text(size = 20,\n                                  hjust = .5),\n        plot.subtitle = element_text(size = 15,\n                                     hjust = .5),\n        plot.caption = element_text(size = 10,\n                                    hjust = .5))\n\n\n##### interactive map\ngirafe(ggobj = incGiniGG,\n       width_svg = 13,\n       options = list(\n         opts_hover(css = ''), ## CSS code of line we're hovering over\n         opts_hover_inv(css = \"opacity:0.3;\"), ## CSS code of all other lines\n         opts_tooltip(css = \"background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\",\n                      use_cursor_pos = T),\n         opts_toolbar(position = 'bottomright')\n       ))\n\n\n\n\n\n\n\n\nShow code\npov$ireg &lt;- gsub(' - ', '-', pov$ireg)\npovMap &lt;- left_join(pov, regMap, by = join_by(ireg == DEN_REG))\n##### ggiraph ready map\npovMap$hCount &lt;- round(povMap$hCount*100, 2)\n\npovhGG &lt;- povMap |&gt; \n  filter(anno == 2000 | anno == 2010 |anno == 2020) |&gt;\n  ggplot() +\n  geom_sf_interactive(aes(geometry = geometry, fill = hCount, data_id = ireg, tooltip = hCount), colour = 'black') +\n  facet_wrap(vars(anno)) +\n  labs(x = NULL, y = NULL,\n       title = 'Poverty headcount by region',\n       caption = 'Data: Bank of Italy. Elaborated by Lorenzo Mattioli - Una Regione per Restare') +\n  theme_minimal(base_family = 'Helvetica') +\n  scale_fill_viridis_c(direction = -1, limits = c(0, 51), option = 'inferno') +\n  theme(axis.text.x=element_blank(),\n        axis.ticks.x=element_blank(),\n        axis.text.y=element_blank(),\n        axis.ticks.y=element_blank(),\n        panel.grid = element_blank(),\n        legend.title = element_blank(),\n        plot.title = element_text(size = 20,\n                                  hjust = .5),\n        plot.subtitle = element_text(size = 15,\n                                     hjust = .5),\n        plot.caption = element_text(size = 10,\n                                    hjust = .5))\n\n\n##### interactive map\ngirafe(ggobj = povhGG,\n       width_svg = 13,\n       options = list(\n         opts_hover(css = ''), ## CSS code of line we're hovering over\n         opts_hover_inv(css = \"opacity:0.3;\"), ## CSS code of all other lines\n         opts_tooltip(css = \"background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\",\n                      use_cursor_pos = T),\n         opts_toolbar(position = 'bottomright')\n       ))"
  },
  {
    "objectID": "projects/RxR Report inequality and poverty/index.html#ranking-regions-by-inequality-indexes-and-poverty",
    "href": "projects/RxR Report inequality and poverty/index.html#ranking-regions-by-inequality-indexes-and-poverty",
    "title": "Inequality and poverty report",
    "section": "Ranking regions by inequality indexes and poverty",
    "text": "Ranking regions by inequality indexes and poverty\n\nShow code\n# Gini\nginiInc |&gt; \n  filter(year == 2000 | year == 2004 | year == 2008 | year == 2012 | year == 2016 | year == 2020) |&gt; \n  drop_na(rank) |&gt; \n  ggplot(aes(x = year, y = rank, data_id = stratum)) +\n  geom_bump(linewidth = 0.6, color = 'gray90',\n            data = ~. |&gt; filter(stratum != 'Umbria')) +\n  geom_bump(aes(colour = stratum), linewidth = 0.8,\n            data = ~. |&gt; filter(stratum == 'Umbria' | stratum == 'Lombardia' | stratum == 'Abruzzo')) +\n  geom_point(color = 'gray90',\n             data = ~. |&gt; filter(stratum != 'Umbria'),\n             size = 4) +\n  geom_point(aes(colour = stratum),\n             data = ~. |&gt; filter(stratum == 'Umbria' | stratum == 'Lombardia' | stratum == 'Abruzzo'),\n             size = 4) +\n  geom_point(color = 'white', size = 2) +\n  geom_text_interactive(aes(label = stratum, group = stratum), colour = 'gray90', x = 2021, hjust = 0, size = 3.5, family = 'Helvetica',\n                        data = ~. |&gt; filter(year == 2020)) +\n  geom_text(aes(label = stratum, group = stratum), colour = 'black', x = 2021, hjust = 0,, size = 3.5, family = 'Helvetica',\n            data = ~. |&gt; filter(year == 2020 & stratum == 'Umbria' | year == 2020 & stratum == 'Lombardia' | year == 2020 & stratum == 'Abruzzo')) +\n  scale_color_viridis_d(option = 'mako', end = .6) +\n  scale_x_continuous(limits = c(2000, 2024) ,expand = c(0.01, 0), breaks=c(2000, 2004, 2008, 2012, 2016, 2020)) +\n  scale_y_reverse(expand = c(0.02, 0), breaks = c(5, 10, 15, 20)) +\n  labs(x = NULL, y = NULL,\n       title = 'Ranking Italian regions by Gini index',\n       subtitle = 'Equivalent household income',\n       caption = 'Data: Bank of Italy. Elaborated by Lorenzo Mattioli - Una Regione per Restare') +\n  theme_minimal(base_family = 'Helvetica') +\n  theme(\n    legend.position = 'none',\n    panel.grid = element_blank(),\n    plot.title = element_text(size = 20,\n                              hjust = .5),\n    plot.subtitle = element_text(size = 15,\n                                 hjust = .5),\n    plot.caption = element_text(size = 10,\n                                hjust = .5)\n  )\n# Poverty\npov |&gt; \n  filter(anno == 2000 | anno == 2004 | anno == 2008 | anno == 2012 | anno == 2016 | anno == 2020) |&gt; \n  ggplot(aes(x = anno, y = rankHCount, group = ireg, data_id = ireg)) +\n    geom_bump(linewidth = 0.6, color = \"gray90\", smooth = 6) +\n    geom_bump(aes(colour = ireg), linewidth = 0.8, smooth = 6,\n                data = ~. |&gt; filter(ireg == 'Umbria' | ireg == 'Lombardia' | ireg == 'Abruzzo')) +\n    geom_point(color = \"gray90\", size = 4) +\n    geom_point(aes(colour = ireg),\n               data = ~. |&gt; filter(ireg == 'Umbria' | ireg == 'Lombardia' | ireg == 'Abruzzo'),\n               size = 4) +\n    geom_point(color = 'white', size = 2) +\n    geom_text(aes(label = ireg, group = ireg), colour = 'gray90', x = 2021, hjust = 0, size = 3.5, family = 'Helvetica',\n              data = ~. |&gt; filter(anno == 2020)) +\n    geom_text(aes(label = ireg, group = ireg), colour = 'black', x = 2021, hjust = 0,, size = 3.5, family = 'Helvetica',\n              data = ~. |&gt; filter(anno == 2020 & ireg == 'Umbria' | anno == 2020 & ireg == 'Lombardia' | anno == 2020 & ireg == 'Abruzzo')) +\n    scale_color_manual(values = met.brewer('Degas')) +\n    scale_x_continuous(limits = c(2000, 2024) ,expand = c(0.01, 0), breaks=c(2000, 2010, 2020)) +\n    scale_y_reverse(expand = c(0.02, 0), breaks = c(1, 5, 10, 15, 20)) +\n    labs(x = NULL, y = NULL,\n         title = 'Ranking Italian regions by poverty rate',\n         subtitle = 'Headcount, from poorest to least poor',\n         caption = 'Data: Bank of Italy. Elaborated by Lorenzo Mattioli - Una Regione per Restare') +\n    theme_minimal(base_family = 'Helvetica') +\n    theme(\n      legend.position = 'none',\n      panel.grid = element_blank(),\n      plot.title = element_text(size = 20,\n                           hjust = .5),\n      plot.subtitle = element_text(size = 15,\n                                   hjust = .5),\n      plot.caption = element_text(size = 10,\n                                  hjust = .5)\n    )"
  },
  {
    "objectID": "projects/RxR Report inequality and poverty/index.html#investigating-causes-of-poverty-through-lpm-modeling",
    "href": "projects/RxR Report inequality and poverty/index.html#investigating-causes-of-poverty-through-lpm-modeling",
    "title": "Inequality and poverty report",
    "section": "Investigating causes of poverty through LPM modeling",
    "text": "Investigating causes of poverty through LPM modeling\n\n\nShow code\nlpmresults$vars &lt;- factor(lpmresults$vars, levels=unique(lpmresults$vars))\nlpmresults$roundEst &lt;- round(lpmresults$Estimate, 2)\n\ngglpm &lt;- lpmresults |&gt; \n  filter(vars == 'Titolo di studio') |&gt; \n  mutate(reg = factor(reg, levels = c('Laurea', 'Medie superiori', 'Medie inferiori', 'Licenza elementare', 'Nessuno'))) |&gt; \n  ggplot(aes(x=Estimate, y=reg, colour = vars, data_id = roundEst, tooltip = roundEst)) +\n  geom_vline(xintercept = 0,\n             linewidth = 0.4,\n             color = 'gray70') +\n  geom_linerange_interactive(aes(xmin=`2.5 %`,xmax=`97.5 %`), linewidth = .6) +\n  geom_point_interactive(size = 6) +\n  geom_point(colour = 'white', size = 3) +\n  geom_point_interactive(aes(x = `2.5 %`), shape = '|', size = 6) +\n  geom_point_interactive(aes(x = `97.5 %`), shape = '|', size = 6) +\n  labs(x = NULL, y = NULL,\n       title = 'Probability of relative poverty based on head of household\\'s educational attainment',\n       subtitle = 'Reference category: post-lauream specialisation',\n       caption = 'Data: Bank of Italy. Elaborated by Lorenzo Mattioli - Una Regione per Restare') +\n  scale_color_manual(values = met.brewer('Degas')) +\n  theme_minimal(base_family = 'Helvetica') +\n  theme(panel.grid = element_line(),\n        legend.position = 'none',\n        axis.text = element_text(size = 13),\n        plot.title = element_text(size = 20,\n                                  hjust = 0),\n        plot.subtitle = element_text(size = 15,\n                                     hjust = 0),\n        plot.caption = element_text(size = 10,\n                                    hjust = .5))\n\ngirafe(ggobj = gglpm,\n       width_svg = 13,\n       options = list(\n         opts_hover(css = ''), ## CSS code of line we're hovering over\n         opts_hover_inv(css = \"opacity:0.3;\"), ## CSS code of all other lines\n         opts_tooltip(css = \"background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\",\n                      use_cursor_pos = T),\n         opts_toolbar(position = 'bottomright')))"
  },
  {
    "objectID": "projects/RxR Quest_23/Index.html",
    "href": "projects/RxR Quest_23/Index.html",
    "title": "RxR Questionnaire - 2023",
    "section": "",
    "text": "In 2023, a team of researchers realised a social survey for the Umbrian association una Regione per Restare - RxR. The research focused mainly on two questions:\nAs this was the first research project promoted by the association, the sample is patchy and excessively small. Since the survey was administered through snow-balling, there is also an evident self-selection problem (too many students, too many individuals aged 20-25 due to the survey being distributed mainly through universities). These problems have been discussed at length internally and will all be taken into account in future projects. In the meantime, the data was used to conduct a merely descriptive analysis, in order to obtain at list a few hints on the next steps to be taken. A good portion of this exact work was carried out in order to explain the issues with the data collection process itself to a non-technical audience.\nAbout a year after the beginning of the survey’s distribution, I was involved as a data analyst, and contributed to the writing of the final report. Below is a selection of my contributions, both in terms of internal and external communication.\nSince the whole work was written in Italian, the graphs and charts are not translated. The source code and data is available at the link on the top right, which leads to Lucia Temperini and I’s GitHub repository. Although code boxes were included in the post for reference, the final graphics were post-produced in Pixelmator. A selection of these are included in the gallery right below, before the actual post."
  },
  {
    "objectID": "projects/RxR Quest_23/Index.html#gallery",
    "href": "projects/RxR Quest_23/Index.html#gallery",
    "title": "RxR Questionnaire - 2023",
    "section": "Gallery",
    "text": "Gallery"
  },
  {
    "objectID": "projects/RxR Quest_23/Index.html#coverage",
    "href": "projects/RxR Quest_23/Index.html#coverage",
    "title": "RxR Questionnaire - 2023",
    "section": "Coverage",
    "text": "Coverage\n\n\nShow code\n## Domicilio - cleaning\nAbitare$dom &lt;- as.character(Abitare$dom)\nAbitare$dom &lt;- ifelse(Abitare$dom == 'Stesso della residenza', Abitare$res, Abitare$dom)\n\n## Province\nprov &lt;- geoCod |&gt; \n  select(`Denominazione (Italiana e straniera)`, `Unità territoriale sovracomunale`) |&gt; \n  rename(denom = `Denominazione (Italiana e straniera)`,\n         prov = `Unità territoriale sovracomunale`)\n\nAbitare &lt;- left_join(Abitare, prov, by = join_by(dom == denom))\nAbitare &lt;- Abitare |&gt; \n  relocate(prov, .after = dom) |&gt; \n  rename(prov_dom = prov)\n\n## Select and merge quest data\ndf &lt;- left_join(Lavorare |&gt; \n                  select(id, occ, gen),\n                Abitare |&gt; \n                  select(id, dom, eta))\n### factor età\ndf$eta &lt;- as.numeric(df$eta)\ndf &lt;- df |&gt; \n  mutate(class_eta = case_match(eta,\n                    c(15:19) ~ '15-20',\n                    c(20:24) ~ '20-25',\n                    c(25:29) ~ '25-30',\n                    c(30:34) ~ '30-35',\n                    c(35:39) ~ '35-40',\n                    c(40:45) ~ '40-45'\n  ))\n\n### occ cleaning\ndf &lt;- df |&gt; \n  mutate(occ = gsub((' (inclusi contratti a nero, precari,  di ricerca, stage, servizio civile)'), '', occ, fixed = T),\n         occ = gsub((' (inclusi contratti a nero, precari, di ricerca, stage, servizio civile)'), '', occ, fixed = T))\n\n## dom frequency table\ndomdf &lt;- df |&gt; \n  group_by(dom) |&gt; \n  count()\n### geospatial data merge\ndomdf &lt;- left_join(domdf,\n                sf |&gt;\n                  select(COMUNE, geometry),\n                by = join_by(dom == COMUNE))\n\n\nThe main problem with the questionnaire was its coverage. In discussing the problem with the rest of our organisation, mapping it out was the best way to explain our dissatisfaction with the results. The tooltip reveals the number of responses in each municipality. The extremely low numbers would be a problem in and of themselves, but the extreme concentration in the city of Perugia (where the University is located) renders the sample impossible to use for statistical inference.\nThe gray areas are municipalities (comuni) that we could not reach at all.\n\n\nShow code\n# Dataviz ----------------------------------------------------------------------\n## Mappa copertura geo\n\nggdom &lt;- domdf |&gt; \n  ggplot() +\n  geom_sf(data = umbriasf, aes(geometry = geometry), colour = 'black', fill = 'gray98') +\n  geom_sf_interactive(aes(geometry = geometry, fill = n, data_id = dom, tooltip = n)) +\n  geom_sf_text(data = ~. |&gt; filter(dom != 'Perugia'),\n               aes(geometry = geometry, label = dom), colour = 'black', size = 3) +\n  geom_sf_text(data = ~. |&gt; filter(dom == 'Perugia'),\n               aes(geometry = geometry, label = dom), colour = 'white', size = 3) +\n  scale_fill_viridis_c(option = 'inferno', direction = -1) +\n  labs(title = 'Questionnaire\\'s geographic coverage') +\n  theme_void() +\n  theme(legend.position = 'none',\n        plot.title = element_text(family = 'Helvetica', hjust = .5, size = 20))\n\n\n### Interactive\n\ngirafe(ggobj = ggdom,\n       width_svg = 8,\n       height_svg = 9,\n       options = list(\n         opts_hover(css = ''),\n         opts_hover_inv(css = 'opacity:0.3;'),\n         opts_tooltip(css = \"background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\",\n                      use_cursor_pos = T),\n         opts_toolbar(position = 'bottomright')))\n\n\n\n\n\n\nThe extremely unequal socio-demographical composition of the sample did not reassure us in any way. The choice of snow-balling as a distribution method introduced significant self-selection problems, which lead to the situation shown in the figure\n\n\nShow code\n### Genere/età/occ\ndf |&gt; \n  mutate(gen = case_match(gen,\n                          'Donna' ~ 'Female',\n                          'Uomo' ~ 'Male',\n                          'Non Binario' ~ 'Non-binary'\n                          )) |&gt; \n  ggplot(aes(x = class_eta, fill = occ)) +\n  geom_bar() +\n  scale_fill_met_d('Degas', direction = -1) +\n  facet_wrap(vars(gen)) +\n  theme_minimal() +\n  theme(legend.title = element_blank(),\n        legend.position = 'bottom',\n        axis.title = element_blank(),\n        strip.text = element_text(size = 15),\n        plot.title = element_text(hjust = .5, size = 18))"
  },
  {
    "objectID": "projects/RxR Quest_23/Index.html#living-conditions",
    "href": "projects/RxR Quest_23/Index.html#living-conditions",
    "title": "RxR Questionnaire - 2023",
    "section": "Living conditions",
    "text": "Living conditions\nBuilding on the questionnaire’s questions, an index of satisfaction with one’s living conditions was built. All values are expressed in percentage.\n\n\nShow code\n## Data cleaning/wrangling -----------------------------------------------------\n### Domicilio - cleaning\nAbitare$dom &lt;- as.character(Abitare$dom)\nAbitare$dom &lt;- ifelse(Abitare$dom == 'Stesso della residenza', Abitare$res, Abitare$dom)\n\n## Index recode\nabRecode &lt;- function(x) {case_match(paste(x),\n        'Per nulla' ~ 1,\n        'Poco' ~ 2,\n        'Abbastanza' ~ 3,\n        'Molto' ~ 4\n      )}\n\nAbitare &lt;- Abitare |&gt; \n    mutate(across(c(abQual, abCost, abPriv, abVic, abColl),\n                  abRecode\n                  )\n           )\nrm(abRecode)\n\n### Additive index def\nAbitare &lt;- Abitare |&gt; \n  mutate(abInd = rowSums(across(c(abQual, abCost, abPriv, abVic, abColl)))) |&gt; \n  mutate(abInd = (abInd-5)/15 * 100) |&gt; \n  mutate(abInd = round(abInd, 2)) |&gt; \n  relocate(abInd, .after = abColl)\n\n\n\n\nShow code\n# Dataviz ----------------------------------------------------------------------\n## Index by urban zone\nabPlotZon &lt;- Abitare |&gt; \n  filter(prov_dom == 'Terni' | prov_dom == 'Perugia') |&gt; \n  group_by(zon) |&gt;\n  summarise(meanzon = mean(abInd)) |&gt; \n  mutate(zon = case_match(zon,\n                          'Periferia' ~ 'Suburbs',\n                          'Centro Cittadino' ~ 'City centre',\n                          'Area Rurale' ~ 'Rural area')) |&gt; \n  mutate(ovmean = mean(meanzon),\n         flag = ifelse(meanzon &gt; ovmean, T, F),\n         zon = factor(zon,\n                           levels = zon[order(meanzon)]))\n\nggPlotZon &lt;- abPlotZon |&gt; \n  ggplot(aes(x = zon, y = meanzon, colour = flag, data_id = zon, tooltip = round(meanzon, 2))) +\n  geom_point_interactive(size = 6) +\n  geom_segment_interactive(aes(y = ovmean, yend = meanzon, x = zon, xend = zon)) +\n  geom_point(size = 4, colour = 'white') +\n  scale_y_continuous(n.breaks = 4) +\n  geom_hline(yintercept = abPlotZon$ovmean[1], colour = 'gray70', size = 0.3) +\n  scale_color_met_d('Degas') +\n  coord_flip() +\n  labs(title = 'Living condition satisfaction index',\n       subtitle = 'Decomposition by area') + \n  theme_minimal() +\n  theme(axis.title = element_blank(),\n        legend.position = 'none',\n        plot.title = element_text(hjust = .5, size = 20),\n        plot.subtitle = element_text(hjust = .5, size = 15),\n        axis.text.y = element_text(size = 11))\n\n\n### Interactive graph\ngirafe(ggobj = ggPlotZon,\n       width_svg = 8,\n       options = list(\n         opts_hover(css = ''), ## CSS code of line we're hovering over\n         opts_hover_inv(css = \"opacity:0.3;\"), ## CSS code of all other lines\n         opts_tooltip(css = \"background-color:white;\n                      color:black;\n                      font-family:Helvetica;\n                      font-style:empty;\n                      padding:8px;\n                      border-radius:10px;\",\n                      use_cursor_pos = T),\n         opts_toolbar(position = 'bottomright')))"
  },
  {
    "objectID": "projects/RxR Quest_23/Index.html#should-i-stay-or-should-i-go",
    "href": "projects/RxR Quest_23/Index.html#should-i-stay-or-should-i-go",
    "title": "RxR Questionnaire - 2023",
    "section": "Should I stay or should I go?",
    "text": "Should I stay or should I go?\nThe following section tries to answer the main question directly: what brings people to leave their home? Why do some still decide to stay?\n\nRelationship to Umbria\nThe first step of the analysis was purely descriptive: how big is the fraction of our sample which left, or would like to? An infographic-style waffle chart was the best choice to convey meaning keeping sense of scale.\n\n\nShow code\n## Rapporto con la regione -----------------------------------------------------\n\nRestare |&gt; \n  group_by(rapp) |&gt; \n  count() |&gt; \n  mutate(rapp = case_match(rapp,\n                           'Vorrei restare nel posto in cui vivo' ~\n                             'I\\'d like to stay where I am',\n                           'Sarei contento di vivere e lavorare altrove' ~\n                             'I\\'d like to live and work somewhere else',\n                           'Vorrei restare ma non posso' ~\n                             'I\\'d like to stay, but I can\\'t',\n                           'Vorrei partire ma non posso' ~\n                             'I\\'d like to leave, but I can\\'t'),\n         rapp = factor(rapp, levels = c(\n           'I\\'d like to stay where I am',\n           'I\\'d like to stay, but I can\\'t',\n           'I\\'d like to leave, but I can\\'t',\n           'I\\'d like to live and work somewhere else'\n         ))) |&gt; \n  waffle(size = 1,\n         flip = T,\n         reverse = T,\n         legend_pos = 'right')"
  },
  {
    "objectID": "projects/RxR Quest_23/Index.html#reasons-for-staying",
    "href": "projects/RxR Quest_23/Index.html#reasons-for-staying",
    "title": "RxR Questionnaire - 2023",
    "section": "Reasons for staying",
    "text": "Reasons for staying\nThis last section aimed at finding the exact reasons why people either stay or go. Radar plots were the best way to convey the relative importance of each individual reason.\n\nShow code\n## Motivi per restare ----------------------------------------------------------\n\n### graphics df\n#### counting each column\nrest &lt;- tibble(.rows = 4, choice = c('Per nulla',\n                                     'Poco',\n                                     'Abbastanza',\n                                     'Molto'))\nfor (i in 1:10) {\nvec &lt;- Restare[startsWith(names(Restare),\"rest\")] |&gt; \n    group_by(Restare[startsWith(names(Restare),\"rest\")][i]) |&gt;\n    drop_na() |&gt; \n    count(name = paste(names(Restare[startsWith(names(Restare),\"rest\")][i]), '_n')) |&gt; \n    rename('choice' = names(Restare[startsWith(names(Restare),\"rest\")][i]))\n\nrest &lt;- full_join(rest, vec |&gt; mutate(choice = choice))\n\n}\nrm(i)\n#### data wrangling\nrest2 &lt;- data.frame(t(rest[-1])) # swapping columns-rows\ncolnames(rest2) &lt;- rest$choice\n\nrest &lt;- rownames_to_column(rest2) |&gt;\n  mutate(rowname = gsub('_n', '', rowname)) |&gt; # column \n  rename(choice = rowname)\n\nrm(rest2)\n\nrest &lt;- rest |&gt; \n  mutate(index = round(((Abbastanza + Molto)/89)*100, 2)) # % di abbastanza + molto importante\n\n### graphics\nlabels&lt;-data.frame(\n  y = c(25,50,75,100),\n  x = rep(0.25,4)\n)\nrest |&gt; \n  filter(choice != 'restFort ') |&gt; \n  mutate(choice = case_match(choice,\n                             'restLeg ' ~ 'Legame/impegno per la comunità',\n                             'restSoc ' ~ 'Contatti sociali e umani più gratificanti',\n                             'restNat ' ~ 'Contatto con la natura',\n                             'restQual '    ~ 'Qualità e stile di vita',\n                             'restOpp ' ~ 'Opportunità anche nel restare',\n                             'restImp ' ~ 'Idea imprenditoriale',\n                             'restFam ' ~ 'Esigenze personali/familiari',\n                             'restCost '    ~ 'Costo della vita più basso',\n                             'restAmb ' ~ 'Scarsa importanza alla carriera'\n                             )) |&gt; \n  ggplot(aes(x = choice, y = index, fill = choice)) +\n  geom_col() +\n  coord_polar() +\n  scale_y_continuous(limits = c(0, 85)) +\n  labs(title = 'Motivi per restare') +\n  scale_fill_manual(values = met.brewer('Tiepolo', 9)) +\n  theme_void() +\n  theme(axis.title = element_blank(),\n        legend.position = 'right',\n        legend.title = element_blank(),\n        plot.title = element_text(size = 20, hjust = .5))\n## Motivi per lasciare ---------------------------------------------------------\n\n### graphics df\n#### counting each column\nlasc &lt;- tibble(.rows = 4, choice = c('Abbastanza', 'Molto', 'Per nulla', 'Poco'))\nfor (i in 1:10) {\n  vec &lt;- Restare[startsWith(names(Restare),\"lasc\")] |&gt; \n    group_by(Restare[startsWith(names(Restare),\"lasc\")][i]) |&gt;\n    drop_na() |&gt; \n    count(name = paste(names(Restare[startsWith(names(Restare),\"lasc\")][i]), '_n')) |&gt; \n    rename('choice' = names(Restare[startsWith(names(Restare),\"lasc\")][i]))\n  \n  lasc &lt;- full_join(lasc, vec)\n  \n}\nrm(i)\n#### data wrangling\nlasc2 &lt;- data.frame(t(lasc[-1])) # swapping columns-rows\ncolnames(lasc2) &lt;-  lasc$choice\n\nlasc &lt;- rownames_to_column(lasc2) |&gt;\n  mutate(rowname = gsub('_n', '', rowname)) |&gt; # column \n  rename(choice = rowname)\n\nrm(lasc2)\n\nlasc &lt;- lasc |&gt; \n  mutate(index = round(((Abbastanza + Molto)/166)*100, 2)) # % di abbastanza + molto importante\n\n### graphics\nlabels&lt;-data.frame(\n  y = c(25,50,75,100),\n  x = rep(0.25,4)\n)\nlasc |&gt; \n  mutate(choice = case_match(choice,\n                             'lascEsp ' ~ 'Ampliare i propri orizzonti',\n                             'lascOpp ' ~ 'Formazione/offerte di lavoro',\n                             'lascImp ' ~ 'Idea imprenditoriale',\n                             'lascEst ' ~ 'Bellezza estetica delle città',\n                             'lascSoc ' ~ 'Relazioni sociali',\n                             'lascFam ' ~ 'Realizzazione familiare',\n                             'lascServ '    ~ 'Offerta di servizi',\n                             'lascRit ' ~ 'Realizzarsi per poi tornare',\n                             'lascTent '    ~ 'Tentare a realizzarsi',\n                             'lascCult '    ~ 'Vita culturale più intensa'\n  )) |&gt; \n  ggplot(aes(x = choice, y = index, fill = choice)) +\n  geom_col() +\n  coord_polar() +\n  scale_y_continuous(limits = c(0, 95)) +\n  labs(title = 'Motivi per andare') +\n  scale_fill_manual(values = met.brewer('Tiepolo', 10)) +\n  theme_void() +\n  theme(axis.title = element_blank(),\n        legend.position = 'right',\n        legend.title = element_blank(),\n        plot.title = element_text(size = 20, hjust = .5))"
  },
  {
    "objectID": "index.html#recent-posts",
    "href": "index.html#recent-posts",
    "title": "Lorenzo Mattioli",
    "section": "Recent posts",
    "text": "Recent posts"
  },
  {
    "objectID": "blog/Workshop ricerca sociale/index.html",
    "href": "blog/Workshop ricerca sociale/index.html",
    "title": "Social research workshop",
    "section": "",
    "text": "On January 4th, 2025, the association una Regione per Restare - RxR organised a three day long training event. On this occasion, I was asked to give a workshop on methodology and methods of social research. The result was a two-hour long session, packed with activities and stimulating possibilities for exchanging ideas.\nKeynote and material available at this github repo (also linked as this article’s source code).\n\nA special thanks to Maddalena for illustrating some of the slides\n\nIl 4 gennaio 2025, l’associazione una Regione per Restare - RxR ha organizzato un evento formativo di tre giorni. In questa occasione, mi è stato chiesto di tenere un workshop sulla metodologia e i metodi della ricerca sociale. Il risultato è stato una sessione di due ore, ricca di attività e di stimolanti possibilità di scambio di idee.\nUn ringraziamento speciale a Maddalena per aver illustrato alcune delle slide\n\n\nLa presentazione che ho utilizzato è disponibile qui sotto (in italiano). Il materiale didattico nella sua interezza è disponibile alla repo github linkata come codice sorgente di questo articolo.\n\n\n  Download PDF File\n   \n    Unable to display PDF file. Download instead."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Lorenzo Mattioli",
    "section": "",
    "text": "About me\nI have a background in Economics, and am now a Master student in Politics and Social Policy at the University of Bologna. I am also involved with the association una Regione per Restare (RxR) as head of their Social Observatory.\nDue to my mixed background, I can count on both solid foundations in data analysis and econometrics and extensive domain knowledge in social sciences.\nMy main research interests revolve around social stratification and material inequality, but this site will also accommodate some of my less “serious” work, as well as some teaching material.\n\nMy complete resume is available here:"
  }
]